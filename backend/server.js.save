require('dotenv').config();
const express = require('express');
const mysql = require('mysql2');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const multer = require('multer');
const xlsx = require('xlsx');
const { jsPDF } = require("jspdf");
const autoTable = require('jspdf-autotable').default;
const apiPaths = require('./config/apiPaths');
const QRCode = require('qrcode');

const app = express();
const port = process.env.PORT || 3001;
const JWT_SECRET = process.env.JWT_SECRET;

if (!JWT_SECRET) {
    console.error("ERREUR FATALE : La variable d'environnement JWT_SECRET n'est pas définie.");
    process.exit(1);
}

const upload = multer({ storage: multer.memoryStorage() });

app.use(cors());
app.use(express.json());

const db = mysql.createPool({
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_DATABASE
}).promise();

const logActivity = async (userId, userName, actionType, description) => {
    try {
        // La colonne 'statut' sera automatiquement mise à 'non_vu' grâce au DEFAULT de la BDD.
        const query = "INSERT INTO historique_activites (utilisateur_id, nom_utilisateur, type_action, description) VALUES (?, ?, ?, ?)";
        await db.query(query, [userId, userName, actionType, description]);
    } catch (err) {
        console.error("Erreur critique lors de la journalisation de l'activité:", err);
    }
};

const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];
    if (token == null) return res.status(401).json({ message: "Accès non autorisé : Token manquant." });

    jwt.verify(token, JWT_SECRET, (err, user) => {
        if (err) return res.status(403).json({ message: "Accès refusé : Token invalide ou expiré." });
        req.user = user;
        next();
    });
};

const checkRole = (rolesAutorises) => {
    return (req, res, next) => {
        if (!rolesAutorises.includes(req.user.role)) {
            return res.status(403).json({ message: "Accès refusé : Permissions insuffisantes." });
        }
        next();
    };
};

app.post(apiPaths.login, async (req, res) => {
    try {
        const { nom_utilisateur, password } = req.body;
        if (!nom_utilisateur || !password) {
            return res.status(400).json({ message: "Nom d'utilisateur et mot de passe requis." });
        }
        const [users] = await db.query("SELECT * FROM utilisateurs WHERE nom_utilisateur = ?", [nom_utilisateur]);
        if (users.length === 0 || password !== users[0].mot_de_passe) {
            await logActivity(null, nom_utilisateur, 'CONNEXION_ECHOUEE', `Tentative de connexion avec un mot de passe incorrect pour '${nom_utilisateur}'.`);
            return res.status(401).json({ message: "Nom d'utilisateur ou mot de passe incorrect." });
        }
        const user = users[0];
        if (user.statut !== 'approuve') {
            await logActivity(user.id, user.nom_utilisateur, 'CONNEXION_ECHOUEE', `Tentative de connexion pour le compte non approuvé '${user.nom_utilisateur}'.`);
            return res.status(403).json({ message: "Votre compte n'a pas encore été validé par un administrateur." });
        }

        const tokenPayload = { id: user.id, role: user.role, nom_utilisateur: user.nom_utilisateur };
        const token = jwt.sign(tokenPayload, JWT_SECRET, { expiresIn: '8h' });

        await logActivity(user.id, user.nom_utilisateur, 'CONNEXION_REUSSIE', `Connexion réussie.`);
        res.json({ token });
    } catch (err) {
        console.error("Erreur sur /api/login", err);
        res.status(500).json({ error: "Une erreur interne est survenue." });
    }
});

app.get('/api/logs/activites', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const [logs] = await db.query("SELECT id, date_action, nom_utilisateur, type_action, description, statut FROM historique_activites ORDER BY date_action DESC LIMIT 500");
        res.json(logs);
    } catch (err) {
        console.error("Erreur sur GET /api/logs/activites", err);
        res.status(500).json({ message: "Erreur lors de la récupération du journal d'activités." });
    }
});

app.get('/api/logs/unread', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const [logs] = await db.query("SELECT id, date_action, nom_utilisateur, type_action, description, statut FROM historique_activites WHERE statut = 'non_vu' ORDER BY date_action DESC");
        res.json(logs);
    } catch (err) {
        console.error("Erreur sur GET /api/logs/unread", err);
        res.status(500).json({ message: "Erreur lors de la récupération des journaux non lus." });
    }
});

// 2. NOUVEAU : Endpoint pour compter les logs non lus
app.get('/api/logs/unread-count', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const [[{ count }]] = await db.query("SELECT COUNT(*) as count FROM historique_activites WHERE statut = 'non_vu'");
        res.json({ count });
    } catch (err) {
        console.error("Erreur sur GET /api/logs/unread-count", err);
        res.status(500).json({ message: "Erreur lors du comptage des journaux non lus." });
    }
});

// 3. NOUVEAU : Endpoint pour marquer tous les logs comme lus
app.put('/api/logs/mark-as-read', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        await db.query("UPDATE historique_activites SET statut = 'vu' WHERE statut = 'non_vu'");
        res.status(200).json({ message: "Tous les journaux ont été marqués comme lus." });
    } catch (err) {
        console.error("Erreur sur PUT /api/logs/mark-as-read", err);
        res.status(500).json({ message: "Erreur lors de la mise à jour des journaux." });
    }
});

app.post('/api/register', async (req, res) => {
    try {
        const { nom, prenom, matricule, service, numero_telephone, nom_utilisateur, mot_de_passe, role } = req.body;

        if (!nom || !prenom || !nom_utilisateur || !mot_de_passe || !role) {
            return res.status(400).json({ message: "Tous les champs marqués d'un * et le rôle sont requis." });
        }

        const rolesAutorises = ['admin', 'operateur_code', 'operateur_note'];
        if (!rolesAutorises.includes(role)) {
            return res.status(400).json({ message: "Le rôle sélectionné est invalide." });
        }

        const query = `
            INSERT INTO utilisateurs (nom, prenom, matricule, service, numero_telephone, nom_utilisateur, mot_de_passe, role)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        `;

        await db.query(query, [nom, prenom, matricule, service, numero_telephone, nom_utilisateur, mot_de_passe, role]);

        res.status(201).json({ message: "Votre demande de création de compte a été envoyée. Elle est en attente de validation par un administrateur." });

    } catch (err) {
        if (err.code === 'ER_DUP_ENTRY') {
            return res.status(409).json({ message: "Ce nom d'utilisateur est déjà pris." });
        }
        console.error("Erreur sur /api/register", err);
        res.status(500).json({ error: "Une erreur interne est survenue lors de l'enregistrement." });
    }
});

app.get(apiPaths.eleves.base, authenticateToken, async (req, res) => {
    try {
        const [rows] = await db.query("SELECT * FROM eleves ORDER BY nom, prenom");
        res.json(rows);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});

app.get(apiPaths.eleves.recherche, authenticateToken, async (req, res) => {
    try {
        const searchTerm = req.query.q;
        if (!searchTerm || searchTerm.trim() === '') return res.json([]);
        const nameSearchQuery = `%${searchTerm}%`;
        const incorpSearchQuery = `${searchTerm}%`;
        const query = `
            SELECT id, prenom, nom, numero_incorporation, escadron, peloton
            FROM eleves
            WHERE numero_incorporation LIKE ? OR CONCAT(prenom, ' ', nom) LIKE ? OR CONCAT(nom, ' ', prenom) LIKE ?
            ORDER BY nom, prenom LIMIT 20;
        `;
        const [rows] = await db.query(query, [incorpSearchQuery, nameSearchQuery, nameSearchQuery]);
        res.json(rows);
    } catch (err) {
        console.error("Erreur sur /api/eleves/recherche", err);
        res.status(500).json({ error: "Erreur lors de la recherche des élèves." });
    }
});

app.post(apiPaths.eleves.importer, authenticateToken, checkRole(['admin']), upload.single('fichierEleves'), async (req, res) => {
    if (!req.file) return res.status(400).json({ message: "Aucun fichier n'a été envoyé." });
    const connection = await db.getConnection();
    try {
        const workbook = xlsx.read(req.file.buffer, { type: 'buffer' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const data = xlsx.utils.sheet_to_json(worksheet, { header: 1 });
        const elevesToInsert = [];
        const numerosIncorporationVus = new Set();
        for (const row of data.slice(1)) {
            if (!row || row.length === 0) continue;
            const numero_incorporation = row[0] ? String(row[0]).trim() : null;
            if (!numero_incorporation || numerosIncorporationVus.has(numero_incorporation)) continue;
            numerosIncorporationVus.add(numero_incorporation);
            const nom_prenom = row[1] ? String(row[1]).trim() : '';
            const sexeRaw = row[2] ? String(row[2]).trim().toUpperCase() : null;
            let nom = '', prenom = '';
            const firstSpaceIndex = nom_prenom.indexOf(' ');
            if (firstSpaceIndex > 0) {
                nom = nom_prenom.substring(0, firstSpaceIndex).trim();
                prenom = nom_prenom.substring(firstSpaceIndex + 1).trim();
            } else { nom = nom_prenom; }
            let sexe = (sexeRaw === 'F' || sexeRaw === 'FEMININ') ? 'feminin' : ((sexeRaw === 'M' || sexeRaw === 'MASCULIN') ? 'masculin' : null);
            const escadron = !isNaN(parseInt(row[3], 10)) ? parseInt(row[3], 10) : null;
            const peloton = !isNaN(parseInt(row[4], 10)) ? parseInt(row[4], 10) : null;
            elevesToInsert.push([nom, prenom, numero_incorporation, sexe, escadron, peloton]);
        }
        if (elevesToInsert.length === 0) return res.status(400).json({ message: "Le fichier ne contient aucun élève valide à importer." });

        await connection.beginTransaction();
        await connection.query("DELETE FROM historique_activites");
        await connection.query("DELETE FROM copies");
        await connection.query("DELETE FROM eleves");
        const sql = "INSERT INTO eleves (nom, prenom, numero_incorporation, sexe, escadron, peloton) VALUES ?";
        await connection.query(sql, [elevesToInsert]);
        await connection.commit();

        await logActivity(req.user.id, req.user.nom_utilisateur, 'IMPORT_ELEVES', `A importé ${elevesToInsert.length} élèves via '${req.file.originalname}'. La base des élèves, copies et activités a été réinitialisée.`);
        res.json({ message: `Base réinitialisée. ${elevesToInsert.length} élèves importés.` });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur lors de l'importation des élèves", err);
        res.status(500).json({ message: "Erreur interne lors du traitement du fichier." });
    } finally {
        connection.release();
    }
});

app.get(apiPaths.matieres.base, authenticateToken, async (req, res) => {
    try {
        const [rows] = await db.query("SELECT id, nom_matiere, code_prefixe AS prefixe, coefficient FROM matieres ORDER BY nom_matiere");
        res.json(rows);
    } catch (err) {
        res.status(500).json({ error: err.message });
    }
});
app.post(apiPaths.matieres.base, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { nom_matiere } = req.body;
        if (!nom_matiere || nom_matiere.trim() === '') {
            return res.status(400).json({ message: "Le nom de la matière est requis." });
        }
        await db.query("INSERT INTO matieres (nom_matiere) VALUES (?)", [nom_matiere.trim()]);
        
        await logActivity(req.user.id, req.user.nom_utilisateur, 'CREATION_MATIERE', `A créé la matière '${nom_matiere.trim()}'.`);
        res.status(201).json({ message: `La matière "${nom_matiere}" a été créée.` });
    } catch (err) {
        if (err.code === 'ER_DUP_ENTRY') return res.status(409).json({ message: "Cette matière existe déjà." });
        res.status(500).json({ error: err.message });
    }
});

app.get('/api/codes/verifier/:code', authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    try {
        const { code } = req.params;
        const [rows] = await db.query("SELECT id FROM codes_anonymes_disponibles WHERE code = ?", [code]);
        if (rows.length > 0) {
            res.status(200).json({ isValid: true, message: "Code valide." });
        } else {
            res.status(404).json({ isValid: false, message: "Ce code n'existe pas dans la base." });
        }
    } catch (err) {
        console.error("Erreur sur /api/codes/verifier/:code", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.post(apiPaths.codes.importer, authenticateToken, checkRole(['admin']), upload.single('fichierCodes'), async (req, res) => {
    if (!req.file) return res.status(400).json({ message: "Aucun fichier n'a été envoyé." });
    const connection = await db.getConnection();
    try {
        const workbook = xlsx.read(req.file.buffer, { type: 'buffer' });
        const worksheet = workbook.Sheets[workbook.SheetNames[0]];
        const data = xlsx.utils.sheet_to_json(worksheet, { header: 1 });
        const codesColonneA = data.slice(1).map(row => row && row[0]).filter(code => code !== null && code !== undefined && code.toString().trim() !== '');
        if (codesColonneA.length === 0) {
            return res.status(400).json({ message: "Le fichier ne contient aucun code valide dans la colonne A." });
        }
        const codesUniques = [...new Set(codesColonneA.map(code => code.toString().trim()))];
        const codesAInserer = codesUniques.map(code => [code]);
        await connection.beginTransaction();
        await connection.query("DELETE FROM codes_anonymes_disponibles");
        await connection.query("INSERT INTO codes_anonymes_disponibles (code) VALUES ?", [codesAInserer]);
        await connection.commit();
        res.status(200).json({ message: `Importation réussie. ${codesAInserer.length} codes anonymes uniques ont été enregistrés.` });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur lors de l'importation des codes anonymes :", err);
        res.status(500).json({ message: "Une erreur interne est survenue lors du traitement du fichier." });
    } finally {
        if (connection) connection.release();
    }
});

// DANS /var/www/projet-anonymat/backend/server.js

app.post('/api/noter-copie-anonyme', authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    // AJOUT : Récupérer 'type_examen' depuis le corps de la requête
    const { matiere_id, code_anonyme, note, type_examen } = req.body;
    const { id: utilisateurId, nom_utilisateur } = req.user;

    // MODIFICATION : Ajouter 'type_examen' dans la validation
    if (!matiere_id || !code_anonyme || note === undefined || note === '' || !type_examen) {
        return res.status(400).json({ message: "Matière, code, note et type d'examen sont requis." });
    }
    const noteNum = parseFloat(note);
    if (isNaN(noteNum) || noteNum < 0 || noteNum > 20) {
         return res.status(400).json({ message: "La note doit être un nombre entre 0 et 20." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();
        const [codesDispo] = await connection.query("SELECT id FROM codes_anonymes_disponibles WHERE code = ?", [code_anonyme]);
        if (codesDispo.length === 0) {
            await connection.rollback();
            return res.status(404).json({ message: "Ce code anonyme n'existe pas dans la base de données générale." });
        }
        const [existingCopies] = await connection.query("SELECT note FROM copies WHERE code_anonyme = ? AND matiere_id = ?", [code_anonyme, matiere_id]);
        if (existingCopies.length > 0 && existingCopies[0].note !== null) {
            await connection.rollback();
            return res.status(409).json({ message: "Ce code a déjà une note enregistrée." });
        }

        // MODIFICATION : Ajouter 'type_examen' dans la requête SQL
        const query = `
            INSERT INTO copies (matiere_id, code_anonyme, note, type_examen, note_saisie_par_utilisateur_id, eleve_id) 
            VALUES (?, ?, ?, ?, ?, NULL) 
            ON DUPLICATE KEY UPDATE 
                note = VALUES(note), 
                type_examen = VALUES(type_examen), 
                note_saisie_par_utilisateur_id = VALUES(note_saisie_par_utilisateur_id)
        `;
        // MODIFICATION : Ajouter 'type_examen' dans les paramètres
        await connection.query(query, [matiere_id, code_anonyme, noteNum, type_examen, utilisateurId]);
        await connection.commit();

        await logActivity(utilisateurId, nom_utilisateur, 'SAISIE_NOTE_ANONYME', `A saisi la note ${noteNum} (type: ${type_examen}) pour le code '${code_anonyme}'.`);
        res.status(201).json({ message: `Note pour le code ${code_anonyme} enregistrée.` });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur /api/noter-copie-anonyme", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    } finally {
        connection.release();
    }
});

app.post('/api/reclamations', authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    const { matiere_id, code_anonyme, note_proposee } = req.body;
    const utilisateurId = req.user.id;

    if (!matiere_id || !code_anonyme || note_proposee === undefined) {
        return res.status(400).json({ message: "Toutes les informations sont requises pour le signalement." });
    }
    try {
        const query = `
            INSERT INTO reclamations (code_anonyme, matiere_id, note_proposee, signale_par_utilisateur_id)
            VALUES (?, ?, ?, ?)
        `;
        await db.query(query, [code_anonyme, matiere_id, note_proposee, utilisateurId]);
        res.status(201).json({ message: "L'incident a été signalé à l'administrateur. Merci." });
    } catch (err) {
        console.error("Erreur sur /api/reclamations", err);
        res.status(500).json({ error: "Erreur interne du serveur lors du signalement." });
    }
});

app.get('/api/reclamations', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const query = `
            SELECT r.id, r.code_anonyme, r.note_proposee, r.date_reclamation, r.statut,
                   m.nom_matiere, u.nom_utilisateur as signale_par
            FROM reclamations r
            JOIN matieres m ON r.matiere_id = m.id
            JOIN utilisateurs u ON r.signale_par_utilisateur_id = u.id
            WHERE r.statut = 'nouveau'
            ORDER BY r.date_reclamation DESC
        `;
        const [reclamations] = await db.query(query);
        res.json(reclamations);
    } catch (err) {
        console.error("Erreur sur GET /api/reclamations", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.get('/api/reclamations/details/:code_anonyme/:matiereId', authenticateToken, checkRole(['admin']), async (req, res) => {
    const { code_anonyme, matiereId } = req.params;
    try {
        const query = `
            SELECT
                c.note AS note_originale,
                c.note_saisie_a AS date_saisie_originale,
                u.nom, u.prenom, u.matricule, u.service, u.numero_telephone, u.nom_utilisateur
            FROM copies c
            JOIN utilisateurs u ON c.note_saisie_par_utilisateur_id = u.id
            WHERE c.code_anonyme = ? AND c.matiere_id = ?
        `;
        const [details] = await db.query(query, [code_anonyme, matiereId]);

        if (details.length === 0) {
            return res.status(404).json({ message: "Impossible de trouver la saisie originale correspondante." });
        }
        res.json(details[0]);

    } catch (err) {
        console.error("Erreur sur GET /api/reclamations/details", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.put('/api/reclamations/:id/resoudre', authenticateToken, checkRole(['admin']), async (req, res) => {
    const { id } = req.params;
    try {
        await db.query("UPDATE reclamations SET statut = 'resolu' WHERE id = ?", [id]);
        res.json({ message: "Réclamation marquée comme résolue." });
    } catch (err) {
        console.error("Erreur sur PUT /api/reclamations/:id/resoudre", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.put('/api/reclamations/corriger', authenticateToken, checkRole(['admin']), async (req, res) => {
    const { reclamationId, code_anonyme, matiereId, nouvelle_note } = req.body;
    const adminId = req.user.id;

    if (!reclamationId || !code_anonyme || !matiereId || nouvelle_note === undefined) {
        return res.status(400).json({ message: "Toutes les informations sont requises pour la correction." });
    }

    const noteNum = parseFloat(nouvelle_note);
    if (isNaN(noteNum) || noteNum < 0 || noteNum > 20) {
        return res.status(400).json({ message: "La nouvelle note doit être un nombre entre 0 et 20." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();

        const [copies] = await connection.query("SELECT id, note FROM copies WHERE code_anonyme = ? AND matiere_id = ?", [code_anonyme, matiereId]);
        if (copies.length === 0) {
            await connection.rollback();
            return res.status(404).json({ message: "Copie originale non trouvée." });
        }
        const copieId = copies[0].id;
        const ancienne_note = copies[0].note;
        const motif = `Correction suite à la réclamation #${reclamationId}.`;

        await connection.query(
            "INSERT INTO historique_modifications_notes (copie_id, ancienne_note, nouvelle_note, motif, modifie_par_utilisateur_id) VALUES (?, ?, ?, ?, ?)",
            [copieId, ancienne_note, noteNum, motif, adminId]
        );

        await connection.query("UPDATE copies SET note = ? WHERE id = ?", [noteNum, copieId]);
        await connection.query("UPDATE reclamations SET statut = 'resolu' WHERE id = ?", [reclamationId]);

        await connection.commit();
        res.json({ message: "La note a été corrigée et la réclamation résolue." });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur PUT /api/reclamations/corriger", err);
        res.status(500).json({ message: "Erreur interne du serveur lors de la correction." });
    } finally {
        connection.release();
    }
});

app.put('/api/lier-copie', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    const { eleve_id, matiere_id, code_anonyme } = req.body;
    const { id: utilisateurId, nom_utilisateur } = req.user;
    if (!eleve_id || !matiere_id || !code_anonyme) {
        return res.status(400).json({ message: "Élève, matière et code sont requis pour la liaison." });
    }
    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();
        const [copies] = await connection.query("SELECT eleve_id, matiere_id FROM copies WHERE code_anonyme = ? FOR UPDATE", [code_anonyme]);
        if (copies.length === 0) {
            await connection.rollback();
            return res.status(404).json({ message: "Aucune note n'a été trouvée pour ce code. Veuillez le noter d'abord." });
        }
        const copie = copies[0];
        if (copie.eleve_id !== null) {
            await connection.rollback();
            return res.status(409).json({ message: "Cette copie est déjà liée à un autre élève." });
        }
        if (copie.matiere_id.toString() !== matiere_id.toString()) {
            await connection.rollback();
            return res.status(409).json({ message: `Conflit : Ce code a été noté pour une autre matière.` });
        }
        const [existingLink] = await connection.query("SELECT id FROM copies WHERE eleve_id = ? AND matiere_id = ?", [eleve_id, matiere_id]);
        if (existingLink.length > 0) {
             await connection.rollback();
             return res.status(409).json({ message: "Cet élève est déjà lié à une autre copie pour cette matière." });
        }
        await connection.query("UPDATE copies SET eleve_id = ?, cree_par_utilisateur_id = ? WHERE code_anonyme = ?", [eleve_id, utilisateurId, code_anonyme]);
        await connection.query("UPDATE codes_anonymes_disponibles SET est_utilise = 1 WHERE code = ?", [code_anonyme]);
        await connection.commit();
        
        await logActivity(utilisateurId, nom_utilisateur, 'LIAISON_COPIE', `A lié le code '${code_anonyme}' à l'élève ID ${eleve_id} pour la matière ID ${matiere_id}.`);
        res.status(200).json({ message: "Liaison effectuée avec succès." });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur /api/lier-copie", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    } finally {
        connection.release();
    }
});

app.get(apiPaths.copies.verifier, authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    try {
        const { code } = req.params;
        if (!code) return res.status(400).json({ message: "Le code est requis." });
        const [rows] = await db.query("SELECT id FROM copies WHERE code_anonyme = ?", [code]);
        if (rows.length > 0) {
            res.status(200).json({ existe: true, message: "Code valide." });
        } else {
            res.status(404).json({ existe: false, message: "Ce code de copie n'existe pas." });
        }
    } catch (err) {
        console.error("Erreur sur /api/copies/verifier/:code", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.get('/api/copies/notees-non-liees', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    try {
        const { matiereId } = req.query;
        let query = `
            SELECT c.id, c.code_anonyme, c.note, m.nom_matiere
            FROM copies c JOIN matieres m ON c.matiere_id = m.id
            WHERE c.eleve_id IS NULL AND c.note IS NOT NULL
        `;
        const params = [];
        if (matiereId && matiereId !== 'all') {
            query += ' AND c.matiere_id = ?';
            params.push(matiereId);
        }
        query += ' ORDER BY m.nom_matiere, c.code_anonyme';
        const [rows] = await db.query(query, params);
        res.json(rows);
    } catch (err) {
        console.error("Erreur sur /api/copies/notees-non-liees", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.get('/api/copies/mes-liages', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    try {
        const utilisateurId = req.user.id;
        const query = `
            SELECT c.id, c.code_anonyme, c.note, m.nom_matiere, e.nom, e.prenom, e.numero_incorporation
            FROM copies c
            JOIN matieres m ON c.matiere_id = m.id
            JOIN eleves e ON c.eleve_id = e.id
            WHERE c.cree_par_utilisateur_id = ? ORDER BY c.id DESC
        `;
        const [rows] = await db.query(query, [utilisateurId]);
        res.json(rows);
    } catch (err) {
        console.error("Erreur sur /api/copies/mes-liages", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.get('/api/copies/mes-saisies-notes', authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    try {
        const utilisateurId = req.user.id;
        const query = `
            SELECT c.id, c.code_anonyme, c.note, m.nom_matiere
            FROM copies c JOIN matieres m ON c.matiere_id = m.id
            WHERE c.note_saisie_par_utilisateur_id = ? ORDER BY c.id DESC
        `;
        const [rows] = await db.query(query, [utilisateurId]);
        res.json(rows);
    } catch (err) {
        console.error("Erreur sur /api/copies/mes-saisies-notes", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.get(apiPaths.stats.nonLiesTotal, authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    try {
        const [[{ total: totalEleves }]] = await db.query("SELECT COUNT(*) as total FROM eleves");
        const [[{ total: totalMatieres }]] = await db.query("SELECT COUNT(*) as total FROM matieres");
        const [[{ total: liaisonsEffectuees }]] = await db.query("SELECT COUNT(*) as total FROM copies WHERE eleve_id IS NOT NULL");

        const liaisonsPossibles = totalEleves * totalMatieres;
        const liaisonsRestantes = liaisonsPossibles - liaisonsEffectuees;

        res.json({ totalRestant: liaisonsRestantes >= 0 ? liaisonsRestantes : 0 });
    } catch (err) {
        console.error("Erreur sur /api/stats/non-lies-total", err);
        res.status(500).json({ error: "Erreur lors du calcul des statistiques globales." });
    }
});


app.get(apiPaths.stats.liaisonsUtilisateur, authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    try {
        const [[result]] = await db.query("SELECT COUNT(*) as liaisonsCreees FROM copies WHERE cree_par_utilisateur_id = ?", [req.user.id]);
        res.json(result);
    } catch (err) {
        console.error("Erreur sur /api/stats/liaisons-utilisateur", err);
        res.status(500).json({ error: "Erreur lors du calcul des statistiques utilisateur." });
    }
});

app.get('/api/stats/notes-utilisateur', authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    try {
        const [[result]] = await db.query("SELECT COUNT(*) as notesSaisies FROM copies WHERE note_saisie_par_utilisateur_id = ?", [req.user.id]);
        res.json(result);
    } catch (err) {
        console.error("Erreur sur /api/stats/notes-utilisateur", err);
        res.status(500).json({ error: "Erreur lors du calcul des statistiques utilisateur." });
    }
});

app.get('/api/stats/notation/:matiereId', authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    try {
        const { matiereId } = req.params;
        const [[{ totalEleves }]] = await db.query("SELECT COUNT(*) as totalEleves FROM eleves");
        const [[{ notesSaisies }]] = await db.query("SELECT COUNT(*) as notesSaisies FROM copies WHERE matiere_id = ? AND note IS NOT NULL", [matiereId]);
        const notesManquantes = totalEleves - notesSaisies;
        res.json({ totalEleves, notesManquantes });
    } catch (err) {
        console.error("Erreur sur /api/stats/notation/:matiereId", err);
        res.status(500).json({ error: "Erreur lors du calcul des statistiques de notation." });
    }
});

app.get(apiPaths.matieres.elevesRestants, authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    try {
        const { id } = req.params;
        const [rows] = await db.query(`SELECT COUNT(*) as restants FROM eleves WHERE id NOT IN (SELECT eleve_id FROM copies WHERE matiere_id = ?)`, [id]);
        res.json(rows[0]);
    } catch (err) {
        console.error("Erreur sur /api/matieres/:id/eleves-restants", err);
        res.status(500).json({ error: "Erreur lors du calcul des élèves restants." });
    }
});

// DANS /var/www/projet-anonymat/backend/server.js

app.get(apiPaths.resultats.base, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        // MODIFICATION : Ajouter c.type_examen au SELECT
        const query = `
            SELECT
                c.id AS copie_id, e.prenom, e.nom, e.numero_incorporation, e.escadron, e.peloton,
                m.nom_matiere, m.id as matiere_id, c.note, c.type_examen, c.code_anonyme,
                u_note.nom_utilisateur AS operateur_note, u_code.nom_utilisateur AS operateur_code,
                (SELECT COUNT(*) FROM historique_modifications_notes h WHERE h.copie_id = c.id) AS modifications_count
            FROM copies c
            JOIN eleves e ON c.eleve_id = e.id
            JOIN matieres m ON c.matiere_id = m.id
            LEFT JOIN utilisateurs u_note ON c.note_saisie_par_utilisateur_id = u_note.id
            LEFT JOIN utilisateurs u_code ON c.cree_par_utilisateur_id = u_code.id
            WHERE c.note IS NOT NULL
            ORDER BY m.nom_matiere, e.escadron, e.peloton, CAST(e.numero_incorporation AS UNSIGNED) ASC;
        `;
        const [rows] = await db.query(query);
        res.json(rows);
    } catch (err) {
        console.error("Erreur sur /api/resultats", err);
        res.status(500).json({ error: err.message });
    }
});

app.put('/api/resultats/:copieId', authenticateToken, checkRole(['admin']), async (req, res) => {
    const { copieId } = req.params;
    const { nouvelle_note, motif } = req.body;
    const utilisateurId = req.user.id;
    if (nouvelle_note === undefined || !motif) {
        return res.status(400).json({ message: "La nouvelle note et le motif sont requis." });
    }
    const noteNum = parseFloat(nouvelle_note);
    if (isNaN(noteNum) || noteNum < 0 || noteNum > 20) {
        return res.status(400).json({ message: "La note doit être un nombre entre 0 et 20." });
    }
    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();
        const [copies] = await connection.query("SELECT note FROM copies WHERE id = ?", [copieId]);
        if (copies.length === 0) {
            await connection.rollback();
            return res.status(404).json({ message: "Résultat non trouvé." });
        }
        const ancienne_note = copies[0].note;
        await connection.query(
            "INSERT INTO historique_modifications_notes (copie_id, ancienne_note, nouvelle_note, motif, modifie_par_utilisateur_id) VALUES (?, ?, ?, ?, ?)",
            [copieId, ancienne_note, noteNum, motif, utilisateurId]
        );
        await connection.query("UPDATE copies SET note = ? WHERE id = ?", [noteNum, copieId]);
        await connection.commit();
        res.json({ message: "La note a été mise à jour avec succès." });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur lors de la mise à jour de la note :", err);
        res.status(500).json({ message: "Erreur interne du serveur." });
    } finally {
        connection.release();
    }
});

app.delete('/api/resultats/:copieId', authenticateToken, checkRole(['admin']), async (req, res) => {
    const { copieId } = req.params;
    const utilisateurId = req.user.id;
    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();
        const [copies] = await connection.query("SELECT note FROM copies WHERE id = ?", [copieId]);
        if (copies.length === 0) {
             await connection.rollback();
             return res.status(404).json({ message: "Résultat non trouvé." });
        }
        const ancienne_note = copies[0].note;
        const motif = `Suppression de la note ${ancienne_note}.`;
        await connection.query(
            "INSERT INTO historique_modifications_notes (copie_id, ancienne_note, nouvelle_note, motif, modifie_par_utilisateur_id) VALUES (?, ?, NULL, ?, ?)",
            [copieId, ancienne_note, motif, utilisateurId]
        );
        await connection.query("UPDATE copies SET note = NULL WHERE id = ?", [copieId]);
        await connection.commit();
        res.json({ message: "La note a été supprimée et l'action archivée." });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur lors de la suppression de la note :", err);
        res.status(500).json({ message: "Erreur interne du serveur." });
    } finally {
        connection.release();
    }
});

app.get('/api/resultats/:copieId/historique', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { copieId } = req.params;
        const query = `
            SELECT
                h.ancienne_note, h.nouvelle_note, h.motif, h.date_modification,
                u.nom_utilisateur AS modifie_par
            FROM historique_modifications_notes h
            JOIN utilisateurs u ON h.modifie_par_utilisateur_id = u.id
            WHERE h.copie_id = ?
            ORDER BY h.date_modification DESC;
        `;
        const [historique] = await db.query(query, [copieId]);
        if (historique.length === 0) {
            return res.status(404).json({ message: "Aucun historique trouvé pour cette note." });
        }
        res.json(historique);
    } catch (err) {
        console.error("Erreur lors de la récupération de l'historique:", err);
        res.status(500).json({ message: "Erreur interne du serveur." });
    }
});

app.get(apiPaths.resultats.exporter, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { matiereId } = req.query;
        if (!matiereId) {
            return res.status(400).json({ message: "Veuillez spécifier une matière pour l'exportation." });
        }
        const query = `
            SELECT e.nom, e.prenom, e.numero_incorporation, e.escadron, e.peloton, e.sexe, m.nom_matiere, c.note
            FROM copies c
            JOIN eleves e ON c.eleve_id = e.id
            JOIN matieres m ON c.matiere_id = m.id
            WHERE c.note IS NOT NULL AND m.id = ?
            ORDER BY e.escadron, e.peloton, CAST(e.numero_incorporation AS UNSIGNED) ASC;
        `;
        const [results] = await db.query(query, [matiereId]);
        if (results.length === 0) {
            return res.status(404).json({ message: "Aucun résultat à exporter pour cette matière." });
        }
        const groupedData = results.reduce((acc, result) => {
            const key = `${result.escadron || 'Sans Escadron'} - ${result.peloton || 'Sans Peloton'}`;
            if (!acc[key]) acc[key] = [];
            acc[key].push(result);
            return acc;
        }, {});
        const workbook = xlsx.utils.book_new();
        const nomMatiere = results[0].nom_matiere.toUpperCase();
        for (const groupName in groupedData) {
            const sheetData = groupedData[groupName];
            const headers = ["N° ORDRE", "NOM ET PRENOM", "N° INCORPORATION", "ESCADRON", "PELOTON", "SEXE", "NOTE / 20"];
            const body = sheetData.map((row, index) => [
                index + 1, `${row.nom || ''} ${row.prenom || ''}`.trim(), row.numero_incorporation,
                row.escadron, row.peloton, (row.sexe === 'feminin' ? 'F' : 'M'), row.note
            ]);
            const finalSheetData = [[`FICHE DE RECUEIL DE NOTE - ${nomMatiere}`], [], headers, ...body];
            const worksheet = xlsx.utils.aoa_to_sheet(finalSheetData);
            worksheet["!merges"] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: 6 } }];
            worksheet['!cols'] = [{ wch: 10 }, { wch: 35 }, { wch: 20 }, { wch: 15 }, { wch: 15 }, { wch: 10 }, { wch: 15 }];
            const sheetName = groupName.replace(/[\\/*?:]/g, '').substring(0, 31);
            xlsx.utils.book_append_sheet(workbook, worksheet, sheetName);
        }
        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        const fileName = `Fiche_Notes_${nomMatiere.replace(/ /g, '_')}.xlsx`;
        res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.send(buffer);
    } catch (err) {
        console.error("Erreur sur /api/resultats/exporter", err);
        res.status(500).json({ error: "Erreur lors de la génération du fichier Excel." });
    }
});

app.post('/api/resultats/generer-document-pdf', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { matiereId } = req.body;
        if (!matiereId) {
            return res.status(400).json({ message: "Veuillez spécifier une matière pour la génération du document." });
        }
        const query = `
            SELECT e.nom, e.prenom, e.numero_incorporation, e.escadron, e.peloton, e.sexe, m.nom_matiere, c.note
            FROM copies c JOIN eleves e ON c.eleve_id = e.id JOIN matieres m ON c.matiere_id = m.id
            WHERE c.note IS NOT NULL AND m.id = ?
            ORDER BY e.escadron, e.peloton, CAST(e.numero_incorporation AS UNSIGNED) ASC;
        `;
        const [results] = await db.query(query, [matiereId]);
        if (results.length === 0) {
            return res.status(404).json({ message: "Aucun résultat à générer pour cette matière." });
        }
        const groupedData = results.reduce((acc, result) => {
            const key = `${result.escadron || 'Sans Escadron'} - ${result.peloton || 'Sans Peloton'}`;
            if (!acc[key]) acc[key] = [];
            acc[key].push(result);
            return acc;
        }, {});

        const doc = new jsPDF({ orientation: 'portrait' });
        const nomMatiere = results[0].nom_matiere.toUpperCase();
        let firstPage = true;

        for (const groupName in groupedData) {
            if (!firstPage) {
                doc.addPage('portrait');
            }
            firstPage = false;

            const qrPageData = groupedData[groupName].map((row, index) => ({
                num: index + 1,
                nom: `${row.nom || ''} ${row.prenom || ''}`.trim(),
                inc: row.numero_incorporation,
                note: row.note
            }));
            const qrDataString = JSON.stringify(qrPageData);
            const qrCodeImage = await QRCode.toDataURL(qrDataString);
            const qrCodeSize = 25;
            const pageMargin = 10;
            const qrX = doc.internal.pageSize.getWidth() - qrCodeSize - pageMargin;
            const qrY = pageMargin;
            doc.addImage(qrCodeImage, 'PNG', qrX, qrY, qrCodeSize, qrCodeSize);

            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.text(`FICHE DE RECUEIL DE NOTE - ${nomMatiere}`, doc.internal.pageSize.getWidth() / 2, 20, { align: 'center' });

            const head = [['N°', 'NOM/PRENOM', 'INCOR', 'ESC', 'PON', 'SEXE', 'NOTE / 20']];
            const body = groupedData[groupName].map((row, index) => [
                index + 1,
                `${row.nom || ''} ${row.prenom || ''}`.trim(),
                row.numero_incorporation,
                row.escadron,
                row.peloton,
                (row.sexe === 'feminin' ? 'F' : 'M'),
                parseFloat(row.note).toFixed(2)
            ]);

            autoTable(doc, {
                startY: 35,
                head: head,
                body: body,
                theme: 'grid',
                headStyles: {
                    fillColor: [255, 255, 255],
                    textColor: [0, 0, 0],
                    fontStyle: 'bold',
                    lineColor: [0, 0, 0],
                    lineWidth: 0.1
                },
                styles: {
                    textColor: [0, 0, 0],
                    lineColor: [0, 0, 0],
                    lineWidth: 0.1
                }
            });
        }
        const pdfBuffer = doc.output('arraybuffer');
        const fileName = `Fiche_Notes_${nomMatiere.replace(/ /g, '_')}.pdf`;
        res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
        res.setHeader('Content-Type', 'application/pdf');
        res.send(Buffer.from(pdfBuffer));
    } catch (err) {
        console.error("Erreur sur /api/resultats/generer-document-pdf", err);
        res.status(500).json({ error: "Erreur lors de la génération du fichier PDF." });
    }
});

app.get(apiPaths.utilisateurs.base, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const [users] = await db.query("SELECT id, nom, prenom, nom_utilisateur, role, statut FROM utilisateurs ORDER BY statut, nom_utilisateur");
        res.json(users);
    } catch (err) {
        res.status(500).json({ error: "Erreur lors de la récupération des utilisateurs." });
    }
});

app.post(apiPaths.utilisateurs.base, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { nom_utilisateur, mot_de_passe, role } = req.body;
        if (!nom_utilisateur || !mot_de_passe || !role) return res.status(400).json({ message: "Toutes les informations sont requises." });

        const query = "INSERT INTO utilisateurs (nom, prenom, nom_utilisateur, mot_de_passe, role, statut) VALUES (?, ?, ?, ?, ?, ?)";
        await db.query(query, [nom_utilisateur, '', nom_utilisateur, mot_de_passe, role, 'approuve']);

        await logActivity(req.user.id, req.user.nom_utilisateur, 'CREATION_UTILISATEUR', `A créé l'utilisateur '${nom_utilisateur}' avec le rôle '${role}'.`);
        res.status(201).json({ message: "Utilisateur créé avec succès." });
    } catch (err) {
        if (err.code === 'ER_DUP_ENTRY') return res.status(409).json({ message: "Ce nom d'utilisateur existe déjà." });
        res.status(500).json({ error: "Erreur lors de la création de l'utilisateur." });
    }
});

app.put(apiPaths.utilisateurs.byId, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { id } = req.params;
        const { nom_utilisateur, mot_de_passe, role } = req.body;
        if (!nom_utilisateur || !role) return res.status(400).json({ message: "Le nom d'utilisateur et le rôle sont requis." });
        let query, params;
        if (mot_de_passe) {
            query = "UPDATE utilisateurs SET nom_utilisateur = ?, mot_de_passe = ?, role = ? WHERE id = ?";
            params = [nom_utilisateur, mot_de_passe, role, id];
        } else {
            query = "UPDATE utilisateurs SET nom_utilisateur = ?, role = ? WHERE id = ?";
            params = [nom_utilisateur, role, id];
        }
        const [result] = await db.query(query, params);
        if (result.affectedRows === 0) return res.status(404).json({ message: "Utilisateur non trouvé." });

        await logActivity(req.user.id, req.user.nom_utilisateur, 'MODIFICATION_UTILISATEUR', `A modifié l'utilisateur ID ${id}. Nouveau nom: '${nom_utilisateur}', nouveau rôle: '${role}'.`);
        res.json({ message: "Utilisateur mis à jour avec succès." });
    } catch (err) {
        if (err.code === 'ER_DUP_ENTRY') return res.status(409).json({ message: "Ce nom d'utilisateur existe déjà." });
        res.status(500).json({ error: "Erreur lors de la mise à jour de l'utilisateur." });
    }
});

app.delete(apiPaths.utilisateurs.byId, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { id } = req.params;
        if (parseInt(id, 10) === req.user.id) return res.status(403).json({ message: "Vous ne pouvez pas supprimer votre propre compte." });
        
        const [users] = await db.query("SELECT nom_utilisateur FROM utilisateurs WHERE id = ?", [id]);
        if (users.length === 0) return res.status(404).json({ message: "Utilisateur non trouvé." });
        const userToDelete = users[0].nom_utilisateur;

        const [result] = await db.query("DELETE FROM utilisateurs WHERE id = ?", [id]);
        if (result.affectedRows === 0) return res.status(404).json({ message: "Utilisateur non trouvé." });
        
        await logActivity(req.user.id, req.user.nom_utilisateur, 'SUPPRESSION_UTILISATEUR', `A supprimé l'utilisateur '${userToDelete}' (ID ${id}).`);
        res.json({ message: "Utilisateur supprimé avec succès." });
    } catch (err) {
        res.status(500).json({ error: "Erreur lors de la suppression de l'utilisateur." });
    }
});

app.put('/api/utilisateurs/:id/approuver', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { id } = req.params;
        const { role } = req.body;
        if (!role) {
            return res.status(400).json({ message: "Le rôle est requis pour approuver un utilisateur." });
        }
        const [result] = await db.query("UPDATE utilisateurs SET statut = 'approuve', role = ? WHERE id = ?", [role, id]);
        if (result.affectedRows === 0) {
            return res.status(404).json({ message: "Utilisateur non trouvé." });
        }
        await logActivity(req.user.id, req.user.nom_utilisateur, 'APPROBATION_UTILISATEUR', `A approuvé l'utilisateur ID ${id} avec le rôle '${role}'.`);
        res.json({ message: "Utilisateur approuvé et rôle attribué avec succès." });
    } catch (err) {
        console.error("Erreur lors de l'approbation de l'utilisateur", err);
        res.status(500).json({ error: "Erreur lors de l'approbation de l'utilisateur." });
    }
});

app.put('/api/utilisateurs/:id/rejeter', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { id } = req.params;
        const [result] = await db.query("UPDATE utilisateurs SET statut = 'rejete' WHERE id = ?", [id]);
        if (result.affectedRows === 0) return res.status(404).json({ message: "Utilisateur non trouvé." });
        res.json({ message: "Utilisateur rejeté." });
    } catch (err) {
        res.status(500).json({ error: "Erreur lors du rejet de l'utilisateur." });
    }
});

app.get('/api/stats/copies-par-matiere', authenticateToken, checkRole(['admin', 'operateur_code', 'operateur_note']), async (req, res) => {
    try {
        const query = `
            SELECT
                m.id,
                m.nom_matiere,
                COALESCE(copies_notees.count, 0) AS avec_note,
                COALESCE(codes_totaux.count, 0) - COALESCE(copies_notees.count, 0) AS sans_note
            FROM
                matieres m
            LEFT JOIN (
                SELECT m.id AS matiere_id, COUNT(cad.id) as count
                FROM matieres m
                JOIN codes_anonymes_disponibles cad ON cad.code LIKE CONCAT(m.code_prefixe, '%')
                GROUP BY m.id
            ) AS codes_totaux ON m.id = codes_totaux.matiere_id
            LEFT JOIN (
                SELECT matiere_id, COUNT(*) as count
                FROM copies
                WHERE note IS NOT NULL
                GROUP BY matiere_id
            ) AS copies_notees ON m.id = copies_notees.matiere_id
            ORDER BY m.nom_matiere;
        `;
        const [stats] = await db.query(query);
        res.json(stats);
    } catch (err) {
        console.error("Erreur sur /api/stats/copies-par-matiere", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.get('/api/copies/non-notees', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    try {
        const { matiereId } = req.query;
        let query = `
            SELECT c.id, c.code_anonyme, m.nom_matiere
            FROM copies c JOIN matieres m ON c.matiere_id = m.id
            WHERE c.eleve_id IS NULL AND c.note IS NULL
        `;
        const params = [];
        if (matiereId && matiereId !== 'all') {
            query += ' AND c.matiere_id = ?';
            params.push(matiereId);
        }
        query += ' ORDER BY m.nom_matiere, c.code_anonyme';
        const [rows] = await db.query(query, params);
        res.json(rows);
    } catch (err) {
        console.error("Erreur sur /api/copies/non-notees", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.get('/api/codes/sans-note/:matiereId', authenticateToken, checkRole(['admin', 'operateur_code', 'operateur_note']), async (req, res) => {
    try {
        const { matiereId } = req.params;

        const [[matiere]] = await db.query("SELECT code_prefixe FROM matieres WHERE id = ?", [matiereId]);
        if (!matiere) {
            return res.status(404).json({ message: "Matière non trouvée." });
        }
        const prefixe = matiere.code_prefixe;

        const query = `
            SELECT cad.code
            FROM codes_anonymes_disponibles cad
            LEFT JOIN copies c ON cad.code = c.code_anonyme AND c.matiere_id = ?
            WHERE cad.code LIKE ? AND c.id IS NULL
            ORDER BY cad.code;
        `;

        const [codes] = await db.query(query, [matiereId, `${prefixe}%`]);
        res.json(codes);

    } catch (err) {
        console.error("Erreur sur /api/codes/sans-note/:matiereId", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

app.post('/api/absences/bulk', authenticateToken, checkRole(['admin']), async (req, res) => {
    const absencesData = req.body;
    const utilisateurId = req.user.id;

    if (!Array.isArray(absencesData) || absencesData.length === 0) {
        return res.status(400).json({ message: "Aucune donnée d'absence fournie." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();

        const valuesToInsert = [];
        for (const absence of absencesData) {
            const eleveId = absence.eleve.id;
            const motif = absence.motif || null;
            for (const matiere of absence.matieres) {
                const matiereId = matiere.id;
                valuesToInsert.push([eleveId, matiereId, utilisateurId, motif]);
            }
        }

        if (valuesToInsert.length === 0) {
            await connection.rollback();
            return res.status(400).json({ message: "Les données d'absence sont invalides ou vides." });
        }

        const sql = "INSERT IGNORE INTO absences (eleve_id, matiere_id, enregistre_par_utilisateur_id, motif) VALUES ?";
        const [result] = await connection.query(sql, [valuesToInsert]);

        await connection.commit();

        res.status(201).json({
            message: `${result.affectedRows} absence(s) ont été enregistrée(s) avec succès. ${valuesToInsert.length - result.affectedRows} étaient déjà enregistrées.`
        });

    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur /api/absences/bulk", err);
        res.status(500).json({ message: "Erreur interne lors de l'enregistrement des absences." });
    } finally {
        connection.release();
    }
});

app.get('/api/absences', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const query = `
            SELECT
                a.eleve_id, a.matiere_id, a.motif,
                e.nom, e.prenom, e.numero_incorporation,
                m.nom_matiere
            FROM absences a
            JOIN eleves e ON a.eleve_id = e.id
            JOIN matieres m ON a.matiere_id = m.id
            ORDER BY e.nom, e.prenom;
        `;
        const [rows] = await db.query(query);

        const absencesGroupees = rows.reduce((acc, row) => {
            if (!acc[row.eleve_id]) {
                acc[row.eleve_id] = {
                    eleve: {
                        id: row.eleve_id,
                        nom: row.nom,
                        prenom: row.prenom,
                        numero_incorporation: row.numero_incorporation
                    },
                    matieres: [],
                    motif: row.motif
                };
            }
            acc[row.eleve_id].matieres.push({
                matiere_id: row.matiere_id,
                nom_matiere: row.nom_matiere
            });
            return acc;
        }, {});

        res.json(Object.values(absencesGroupees));

    } catch (err) {
        console.error("Erreur sur GET /api/absences", err);
        res.status(500).json({ message: "Erreur interne lors de la récupération des absences." });
    }
});

app.delete('/api/absences/:eleveId', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { eleveId } = req.params;
        await db.query("DELETE FROM absences WHERE eleve_id = ?", [eleveId]);
        res.json({ message: "Absence(s) supprimée(s) avec succès." });
    } catch (err) {
        console.error("Erreur sur DELETE /api/absences/:eleveId", err);
        res.status(500).json({ message: "Erreur interne lors de la suppression." });
    }
});

app.put('/api/absences/:eleveId', authenticateToken, checkRole(['admin']), async (req, res) => {
    const { eleveId } = req.params;
    const { matieres, motif } = req.body;
    const utilisateurId = req.user.id;

    if (!Array.isArray(matieres) || matieres.length === 0) {
        return res.status(400).json({ message: "Veuillez sélectionner au moins une matière." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();

        await connection.query("DELETE FROM absences WHERE eleve_id = ?", [eleveId]);

        const valuesToInsert = matieres.map(matiereId => [
            eleveId,
            matiereId,
            utilisateurId,
            motif || null
        ]);

        const sql = "INSERT INTO absences (eleve_id, matiere_id, enregistre_par_utilisateur_id, motif) VALUES ?";
        await connection.query(sql, [valuesToInsert]);

        await connection.commit();
        res.json({ message: "Les absences de l'élève ont été mises à jour avec succès." });

    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur PUT /api/absences/:eleveId", err);
        res.status(500).json({ message: "Erreur interne lors de la mise à jour." });
    } finally {
        connection.release();
    }
});

// DANS /var/www/projet-anonymat/backend/server.js

app.post(apiPaths.copies.noteDirecte, authenticateToken, checkRole(['admin','operateur_note']), async (req, res) => {
    const { eleve_id, matiere_id, note, type_examen } = req.body;
    const utilisateurId = req.user.id;

    if (!eleve_id || !matiere_id || note === undefined || note === '' || !type_examen) {
        return res.status(400).json({ message: "Élève, matière, note et type d'examen sont requis." });
    }
    const noteNum = parseFloat(note);
    if (isNaN(noteNum) || noteNum < 0 || noteNum > 20) {
         return res.status(400).json({ message: "La note doit être un nombre valide entre 0 et 20." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();

        // On vérifie les absences comme avant
        const [absenceCheck] = await connection.query(
            "SELECT id FROM absences WHERE eleve_id = ? AND matiere_id = ?",
            [eleve_id, matiere_id]
        );
        if (absenceCheck.length > 0) {
             await connection.rollback();
             return res.status(409).json({ message: "Impossible d'enregistrer la note : cet élève est déclaré absent pour cette matière." });
        }

        // Requête d'insertion/mise à jour
        const query = `
            INSERT INTO copies (eleve_id, matiere_id, note, type_examen, note_saisie_par_utilisateur_id, code_anonyme)
            VALUES (?, ?, ?, ?, ?, NULL)
            ON DUPLICATE KEY UPDATE
                note = VALUES(note),
                note_saisie_par_utilisateur_id = VALUES(note_saisie_par_utilisateur_id);
        `;
        await connection.query(query, [eleve_id, matiere_id, noteNum, type_examen, utilisateurId]);

        await connection.commit();
        res.status(201).json({ message: "Note enregistrée avec succès." });

    } catch (err) {
        await connection.rollback();
        // C'est ici que l'erreur "déjà noté" sera attrapée
        if (err.code === 'ER_DUP_ENTRY') {
            return res.status(409).json({ message: `Cet élève a déjà une note pour cette matière et ce type d'examen.` });
        }
        console.error("Erreur sur /api/note-directe", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    } finally {
        connection.release();
    }
});

// DANS /var/www/projet-anonymat/backend/server.js

app.get('/api/eleves-par-groupe', authenticateToken, checkRole(['admin','operateur_note']), async (req, res) => {
    // On récupère le type d'examen depuis la requête
    const { matiereId, typeExamen, escadron, peloton } = req.query;

    if (!matiereId || !typeExamen || !escadron) {
        return res.status(400).json({ message: "La matière, le type d'examen et l'escadron sont requis." });
    }

    try {
        // On ajoute typeExamen aux paramètres
        let params = [matiereId, typeExamen, matiereId, escadron];
        let pelotonFilter = '';
        if (peloton && peloton !== 'all') {
            pelotonFilter = 'AND e.peloton = ?';
            params.push(peloton);
        }

        // La requête LEFT JOIN vérifie maintenant la note pour la matière ET le type d'examen
        const query = `
            SELECT e.id, e.nom, e.prenom, e.numero_incorporation, e.escadron, e.peloton
            FROM eleves e
            LEFT JOIN copies c ON e.id = c.eleve_id AND c.matiere_id = ? AND c.type_examen = ?
            LEFT JOIN absences a ON e.id = a.eleve_id AND a.matiere_id = ?
            WHERE c.id IS NULL
              AND a.id IS NULL
              AND e.escadron = ?
              ${pelotonFilter}
            ORDER BY e.peloton ASC, CAST(e.numero_incorporation AS UNSIGNED) ASC;
        `;

        const [eleves] = await db.query(query, params);
        res.json(eleves);

    } catch (err) {
        console.error("Erreur sur /api/eleves-par-groupe", err);
        res.status(500).json({ message: "Erreur interne lors de la récupération des élèves." });
    }
});

app.put('/api/matieres/coefficients', authenticateToken, checkRole(['admin']), async (req, res) => {
    const coefficients = req.body;
    if (!Array.isArray(coefficients) || coefficients.length === 0) {
        return res.status(400).json({ message: "Les données des coefficients sont invalides." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();
        const promises = coefficients.map(item => {
            const coeffNum = parseFloat(item.coefficient);
            if (isNaN(coeffNum) || coeffNum < 0) {
                throw new Error(`Coefficient invalide pour la matière ID ${item.id}`);
            }
            return connection.query("UPDATE matieres SET coefficient = ? WHERE id = ?", [coeffNum, item.id]);
        });
        await Promise.all(promises);
        await connection.commit();
        res.json({ message: "Les coefficients ont été mis à jour avec succès." });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur lors de la mise à jour des coefficients :", err);
        res.status(500).json({ message: err.message || "Erreur interne du serveur." });
    } finally {
        connection.release();
    }
});

app.get('/api/resultats/classement', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const [eleves] = await db.query("SELECT id, prenom, nom, numero_incorporation FROM eleves");
        const [matieres] = await db.query("SELECT id, coefficient FROM matieres");
        const [notes] = await db.query("SELECT eleve_id, matiere_id, note FROM copies WHERE note IS NOT NULL");

        const notesMap = new Map();
        notes.forEach(n => {
            notesMap.set(`${n.eleve_id}-${n.matiere_id}`, n.note);
        });

        const totalCoefficients = matieres.reduce((sum, m) => sum + parseFloat(m.coefficient), 0);
        if (totalCoefficients === 0) {
             return res.json([]);
        }

        const resultatsCalcules = eleves.map(eleve => {
            let totalPoints = 0;
            let hasAtLeastOneNote = false;

            matieres.forEach(matiere => {
                const note = notesMap.get(`${eleve.id}-${matiere.id}`);
                if (note !== undefined && note !== null) {
                    totalPoints += parseFloat(note) * parseFloat(matiere.coefficient);
                    hasAtLeastOneNote = true;
                }
            });

            if (!hasAtLeastOneNote) {
                return { ...eleve, moyenne: null, statut: 'Non classé' };
            }

            const moyenne = totalPoints / totalCoefficients;
            return { ...eleve, moyenne: moyenne.toFixed(2), statut: 'Classé' };
        });

        const classes = resultatsCalcules.filter(r => r.statut === 'Classé');
        const nonClasses = resultatsCalcules.filter(r => r.statut === 'Non classé');

        classes.sort((a, b) => b.moyenne - a.moyenne);

        let rang = 0;
        let lastMoyenne = -1;
        let studentsAtCurrentRank = 1;

        const classesAvecRang = classes.map((eleve, index) => {
            if (eleve.moyenne !== lastMoyenne) {
                rang = rang + studentsAtCurrentRank;
                studentsAtCurrentRank = 1;
            } else {
                 studentsAtCurrentRank++;
            }
            lastMoyenne = eleve.moyenne;

            const isExAequo = (index > 0 && eleve.moyenne === classes[index - 1].moyenne) ||
                              (index < classes.length - 1 && eleve.moyenne === classes[index + 1].moyenne);

            return { ...eleve, rang: isExAequo ? `${rang} ex` : rang };
        });

        const classementFinal = [...classesAvecRang, ...nonClasses];
        res.json(classementFinal);

    } catch (err) {
        console.error("Erreur sur /api/resultats/classement :", err);
        res.status(500).json({ error: "Erreur lors du calcul du classement." });
    }
});

// MODIFICATION DE LA ROUTE POUR LE CLASSEMENT DÉTAILLÉ
app.get('/api/resultats/classement-details', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        // AJOUT : Récupérer le type d'examen depuis la query string de l'URL
        const { typeExamen } = req.query;

        const [eleves] = await db.query("SELECT id, prenom, nom, numero_incorporation, escadron, peloton FROM eleves ORDER BY nom, prenom");
        const [matieres] = await db.query("SELECT id, nom_matiere, code_prefixe, coefficient FROM matieres ORDER BY nom_matiere");

        // MODIFICATION : Conditionner la requête des notes
        let notesQuery = "SELECT eleve_id, matiere_id, note FROM copies WHERE note IS NOT NULL";
        const queryParams = [];
        if (typeExamen && typeExamen !== 'General') {
            notesQuery += " AND type_examen = ?";
            queryParams.push(typeExamen);
        }
        const [notes] = await db.query(notesQuery, queryParams);

        const notesMap = new Map();
        notes.forEach(n => {
            notesMap.set(`${n.eleve_id}-${n.matiere_id}`, parseFloat(n.note).toFixed(2));
        });

        const totalCoefficients = matieres.reduce((sum, m) => sum + parseFloat(m.coefficient), 0);
        if (totalCoefficients === 0) {
            return res.json({ classement: [], matieres: [] });
        }

        // Le reste de la logique de calcul reste identique, elle fonctionnera avec les notes déjà filtrées
        const resultatsCalcules = eleves.map(eleve => {
            let totalPoints = 0;
            let hasAtLeastOneNote = false;
            const notesDetail = {};

            matieres.forEach(matiere => {
                const note = notesMap.get(`${eleve.id}-${matiere.id}`);
                if (note !== undefined) {
                    totalPoints += parseFloat(note) * parseFloat(matiere.coefficient);
                    hasAtLeastOneNote = true;
                    notesDetail[matiere.id] = note;
                } else {
                    // MODIFICATION : Pour le détail, on affiche '-' si aucune note n'est trouvée pour ce modèle d'examen
                    notesDetail[matiere.id] = '-';
                }
            });

            if (!hasAtLeastOneNote) {
                return { ...eleve, moyenne: null, statut: 'Non classé', notesDetail };
            }

            const moyenne = totalPoints / totalCoefficients;
            return { ...eleve, moyenne: moyenne.toFixed(2), statut: 'Classé', notesDetail };
        });

        const classes = resultatsCalcules.filter(r => r.statut === 'Classé');
        const nonClasses = resultatsCalcules.filter(r => r.statut === 'Non classé');

        classes.sort((a, b) => b.moyenne - a.moyenne);
        let rang = 0;
        let lastMoyenne = -1;
        let studentsAtCurrentRank = 1;
        const classesAvecRang = classes.map((eleve, index) => {
            if (eleve.moyenne !== lastMoyenne) {
                rang = rang + studentsAtCurrentRank;
                studentsAtCurrentRank = 1;
            } else {
                 studentsAtCurrentRank++;
            }
            lastMoyenne = eleve.moyenne;
            const isExAequo = (index > 0 && eleve.moyenne === classes[index - 1].moyenne) ||
                              (index < classes.length - 1 && eleve.moyenne === classes[index + 1].moyenne);
            return { ...eleve, rang: isExAequo ? `${rang} ex` : rang };
        });

        res.json({
            classement: [...classesAvecRang, ...nonClasses],
            matieres: matieres
        });

    } catch (err) {
        console.error("Erreur sur /api/resultats/classement-details :", err);
        res.status(500).json({ error: "Erreur lors du calcul détaillé du classement." });
    }
});

const getMentionForExcel = (moyenne) => {
    if (moyenne === null || moyenne === undefined) return '-';
    const m = parseFloat(moyenne);
    if (m >= 18) return 'Excellent';
    if (m >= 16) return 'Très bien';
    if (m >= 14) return 'Bien';
    if (m >= 12) return 'Assez bien';
    if (m >= 10) return 'Passable';
    return 'Insuffisant';
};

const assignRankInGroup = (group) => {
    group.sort((a, b) => b.moyenne - a.moyenne);
    let rang = 0;
    let lastMoyenne = -1;
    let studentsAtCurrentRank = 1;
    return group.map((eleve, index) => {
        if (eleve.moyenne !== lastMoyenne) {
            rang = rang + studentsAtCurrentRank;
            studentsAtCurrentRank = 1;
        } else {
            studentsAtCurrentRank++;
        }
        lastMoyenne = eleve.moyenne;
        const isExAequo = (index > 0 && eleve.moyenne === group[index - 1].moyenne) ||
                          (index < group.length - 1 && eleve.moyenne === group[index + 1].moyenne);
        return { ...eleve, rang_groupe: isExAequo ? `${rang} ex` : rang };
    });
};


app.get('/api/resultats/exporter-classement-excel', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const [eleves] = await db.query("SELECT id, prenom, nom, numero_incorporation, escadron, peloton FROM eleves ORDER BY nom, prenom");
        const [matieres] = await db.query("SELECT id, coefficient FROM matieres");
        const [notes] = await db.query("SELECT eleve_id, matiere_id, note FROM copies WHERE note IS NOT NULL");

        const notesMap = new Map();
        notes.forEach(n => { notesMap.set(`${n.eleve_id}-${n.matiere_id}`, parseFloat(n.note)); });

        const totalCoefficients = matieres.reduce((sum, m) => sum + parseFloat(m.coefficient), 0);
        if (totalCoefficients === 0) {
            return res.status(400).json({ message: "Impossible d'exporter, aucun coefficient n'est défini."});
        }

        const resultatsCalcules = eleves.map(eleve => {
            let totalPoints = 0;
            let hasAtLeastOneNote = false;
            matieres.forEach(matiere => {
                const note = notesMap.get(`${eleve.id}-${matiere.id}`);
                if (note !== undefined) {
                    totalPoints += note * parseFloat(matiere.coefficient);
                    hasAtLeastOneNote = true;
                }
            });
            const moyenne = hasAtLeastOneNote ? (totalPoints / totalCoefficients) : null;
            return { ...eleve, moyenne };
        });

        const classes = resultatsCalcules.filter(r => r.moyenne !== null);
        const nonClasses = resultatsCalcules.filter(r => r.moyenne === null);

        classes.sort((a, b) => b.moyenne - a.moyenne);
        let rang = 0;
        let lastMoyenne = -1;
        let studentsAtCurrentRank = 1;
        const classesAvecRang = classes.map((eleve, index) => {
            if (eleve.moyenne !== lastMoyenne) {
                rang += studentsAtCurrentRank;
                studentsAtCurrentRank = 1;
            } else {
                studentsAtCurrentRank++;
            }
            lastMoyenne = eleve.moyenne;
            const isExAequo = (index > 0 && eleve.moyenne === classes[index - 1].moyenne) || (index < classes.length - 1 && eleve.moyenne === classes[index + 1].moyenne);
            return { ...eleve, rang_general: isExAequo ? `${rang} ex` : rang };
        });

        const classementFinal = [...classesAvecRang, ...nonClasses.map(e => ({...e, rang_general: 'Non classé'}))];

        const workbook = xlsx.utils.book_new();
        const generalSheetData = [
            ['RANG GÉNÉRAL', 'NOM ET PRÉNOM', 'N° INCORP.', 'ESCADRON', 'PELOTON', 'MOYENNE', 'MENTION'],
            ...classementFinal.map(e => [
                e.rang_general, `${e.nom} ${e.prenom}`, e.numero_incorporation,
                e.escadron || '-', e.peloton || '-',
                e.moyenne !== null ? e.moyenne.toFixed(2) : '-', getMentionForExcel(e.moyenne)
            ])
        ];
        const generalWorksheet = xlsx.utils.aoa_to_sheet(generalSheetData);
        generalWorksheet['!cols'] = [{wch: 15}, {wch: 30}, {wch: 15}, {wch: 10}, {wch: 10}, {wch: 10}, {wch: 15}];
        xlsx.utils.book_append_sheet(workbook, generalWorksheet, 'Classement Général');

        const groupedByEscadron = classementFinal
            .filter(e => e.moyenne !== null && e.escadron)
            .reduce((acc, eleve) => {
                const key = eleve.peloton ? `${eleve.escadron}-${eleve.peloton}` : `${eleve.escadron}`;

                if (!acc[key]) acc[key] = [];
                acc[key].push(eleve);
                return acc;
            }, {});

        const sortedGroupNames = Object.keys(groupedByEscadron).sort((a, b) => {
            const partsA = a.split('-').map(Number);
            const partsB = b.split('-').map(Number);
            if (partsA[0] !== partsB[0]) return partsA[0] - partsB[0];
            return (partsA[1] || 0) - (partsB[1] || 0);
        });

        for (const groupName of sortedGroupNames) {
            const group = groupedByEscadron[groupName];
            const groupWithRank = assignRankInGroup(group);

            const groupSheetData = [
                ['RANG GROUPE', 'RANG GÉNÉRAL', 'NOM ET PRÉNOM', 'N° INCORP.', 'MOYENNE', 'MENTION'],
                ...groupWithRank.map(e => [
                    e.rang_groupe, e.rang_general, `${e.nom} ${e.prenom}`,
                    e.numero_incorporation, e.moyenne.toFixed(2), getMentionForExcel(e.moyenne)
                ])
            ];
            const groupWorksheet = xlsx.utils.aoa_to_sheet(groupSheetData);
            groupWorksheet['!cols'] = [{wch: 15}, {wch: 15}, {wch: 30}, {wch: 15}, {wch: 10}, {wch: 15}];
            xlsx.utils.book_append_sheet(workbook, groupWorksheet, groupName);
        }

        const buffer = xlsx.write(workbook, { bookType: 'xlsx', type: 'buffer' });
        res.setHeader('Content-Disposition', 'attachment; filename="Classement_General_Detaille.xlsx"');
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.send(buffer);

    } catch (err) {
        console.error("Erreur sur /api/resultats/exporter-classement-excel :", err);
        res.status(500).json({ error: "Erreur lors de la génération du fichier Excel." });
    }
});

app.put('/api/copies/relier/:copieId', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    const { copieId } = req.params;
    const { nouvel_eleve_id, matiere_id } = req.body;
    const utilisateurId = req.user.id;

    if (!nouvel_eleve_id || !matiere_id) {
        return res.status(400).json({ message: "Le nouvel élève et la matière sont requis." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();

        const [existingLink] = await connection.query(
            "SELECT id FROM copies WHERE eleve_id = ? AND matiere_id = ? AND id != ?",
            [nouvel_eleve_id, matiere_id, copieId]
        );
        if (existingLink.length > 0) {
            await connection.rollback();
            return res.status(409).json({ message: "Conflit : ce nouvel élève est déjà lié à une autre copie pour cette matière." });
        }

        const [absenceCheck] = await connection.query(
            "SELECT id FROM absences WHERE eleve_id = ? AND matiere_id = ?",
            [nouvel_eleve_id, matiere_id]
        );
        if (absenceCheck.length > 0) {
            await connection.rollback();
            return res.status(409).json({ message: "Modification impossible : le nouvel élève est déclaré absent pour cette matière." });
        }

        const [updateResult] = await connection.query(
            "UPDATE copies SET eleve_id = ?, cree_par_utilisateur_id = ? WHERE id = ?",
            [nouvel_eleve_id, utilisateurId, copieId]
        );

        if (updateResult.affectedRows === 0) {
            throw new Error("La copie à mettre à jour n'a pas été trouvée.");
        }

        await connection.commit();
        res.json({ message: "Le liage a été modifié avec succès." });

    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur /api/copies/relier/:copieId", err);
        res.status(500).json({ message: err.message || "Erreur interne du serveur lors de la modification." });
    } finally {
        connection.release();
    }
});

app.delete('/api/copies/delier/:copieId', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    const { copieId } = req.params;
    const connection = await db.getConnection();

    try {
        await connection.beginTransaction();

        const [copies] = await connection.query("SELECT code_anonyme FROM copies WHERE id = ?", [copieId]);
        if (copies.length === 0) {
            await connection.rollback();
            return res.status(404).json({ message: "Liage non trouvé." });
        }
        const code_anonyme = copies[0].code_anonyme;

        await connection.query(
            "UPDATE copies SET eleve_id = NULL, cree_par_utilisateur_id = NULL WHERE id = ?",
            [copieId]
        );

        if (code_anonyme) {
             await connection.query("UPDATE codes_anonymes_disponibles SET est_utilise = 0 WHERE code = ?", [code_anonyme]);
        }

        await connection.commit();
        res.json({ message: "Le liage a été supprimé avec succès. Le code est de nouveau disponible." });

    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur /api/copies/delier/:copieId", err);
        res.status(500).json({ message: "Erreur interne du serveur lors de la suppression." });
    } finally {
        connection.release();
    }
});

app.get('/api/anomalies', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    try {
        const query = `
            SELECT
                a.id, a.motif, a.date_signalement,
                m.nom_matiere,
                u.nom_utilisateur AS signale_par
            FROM anomalies a
            JOIN matieres m ON a.matiere_id = m.id
            JOIN utilisateurs u ON a.signale_par_utilisateur_id = u.id
            ORDER BY a.date_signalement DESC;
        `;
        const [anomalies] = await db.query(query);
        res.json(anomalies);
    } catch (err) {
        console.error("Erreur sur GET /api/anomalies", err);
        res.status(500).json({ message: "Erreur interne du serveur." });
    }
});

app.post('/api/anomalies', authenticateToken, checkRole(['admin', 'operateur_code']), async (req, res) => {
    const { matiere_id, motif } = req.body;
    const utilisateurId = req.user.id;

    if (!matiere_id || !motif || motif.trim() === '') {
        return res.status(400).json({ message: "La matière et le motif sont requis pour signaler une anomalie." });
    }

    try {
        const query = "INSERT INTO anomalies (matiere_id, motif, signale_par_utilisateur_id) VALUES (?, ?, ?)";
        await db.query(query, [matiere_id, motif.trim(), utilisateurId]);
        res.status(201).json({ message: "Anomalie signalée avec succès." });
    } catch (err) {
        console.error("Erreur sur POST /api/anomalies", err);
        res.status(500).json({ message: "Erreur interne lors de l'enregistrement de l'anomalie." });
    }
});

app.get('/api/resultats/sans-note/:matiereId', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const { matiereId } = req.params;
        if (!matiereId) {
            return res.status(400).json({ message: "L'identifiant de la matière est requis." });
        }

        const query = `
            SELECT e.id, e.nom, e.prenom, e.numero_incorporation, e.escadron, e.peloton
            FROM eleves e
            WHERE
                e.id NOT IN (
                    SELECT c.eleve_id
                    FROM copies c
                    WHERE c.matiere_id = ? AND c.eleve_id IS NOT NULL AND c.note IS NOT NULL
                )
            AND
                e.id NOT IN (
                    SELECT a.eleve_id
                    FROM absences a
                    WHERE a.matiere_id = ?
                )
            ORDER BY e.escadron, e.peloton, CAST(e.numero_incorporation AS UNSIGNED) ASC;
        `;

        const [eleves] = await db.query(query, [matiereId, matiereId]);
        res.json(eleves);

    } catch (err) {
        console.error("Erreur sur /api/resultats/sans-note/:matiereId :", err);
        res.status(500).json({ error: "Erreur lors de la récupération des élèves sans note." });
    }
});

const calculerClassementComplet = async (dbConnection) => {
    const [eleves] = await dbConnection.query("SELECT id, prenom, nom, numero_incorporation FROM eleves");
    const [matieres] = await dbConnection.query("SELECT id, coefficient FROM matieres");
    const [notes] = await dbConnection.query("SELECT id as copie_id, eleve_id, matiere_id, note FROM copies WHERE note IS NOT NULL");

    const notesMap = new Map();
    notes.forEach(n => {
        notesMap.set(`${n.eleve_id}-${n.matiere_id}`, { note: n.note, copie_id: n.copie_id });
    });

    const totalCoefficients = matieres.reduce((sum, m) => sum + parseFloat(m.coefficient), 0);
    if (totalCoefficients === 0) return [];

    const resultatsCalcules = eleves.map(eleve => {
        let totalPoints = 0;
        let notesDetail = {};
        matieres.forEach(matiere => {
            const noteInfo = notesMap.get(`${eleve.id}-${matiere.id}`);
            if (noteInfo) {
                totalPoints += parseFloat(noteInfo.note) * parseFloat(matiere.coefficient);
                notesDetail[matiere.id] = { note: noteInfo.note, copie_id: noteInfo.copie_id };
            }
        });
        const moyenne = totalPoints / totalCoefficients;
        return { ...eleve, moyenne, notesDetail };
    });

    resultatsCalcules.sort((a, b) => b.moyenne - a.moyenne);

    let rang = 0;
    let lastMoyenne = -1;
    let studentsAtCurrentRank = 1;
    return resultatsCalcules.map((eleve, index) => {
        if (eleve.moyenne !== lastMoyenne) {
            rang += studentsAtCurrentRank;
            studentsAtCurrentRank = 1;
        } else {
            studentsAtCurrentRank++;
        }
        lastMoyenne = eleve.moyenne;
        return { ...eleve, rang };
    });
};

app.get(apiPaths.incognito.classementActuel, authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const classement = await calculerClassementComplet(db);
        res.json(classement);
    } catch (err) {
        console.error("Erreur sur /api/incognito/classement-actuel:", err);
        res.status(500).json({ message: "Erreur interne du serveur." });
    }
});

app.post(apiPaths.incognito.suggestionsMoyenne, authenticateToken, checkRole(['admin']), async (req, res) => {
    const { eleveCibleId, moyenneVisee, rangVise, matiereIds } = req.body;

    if (!eleveCibleId || (!moyenneVisee && !rangVise)) {
        return res.status(400).json({ message: "Élève cible et objectif (moyenne ou rang) sont requis." });
    }

    try {
        const classementActuel = await calculerClassementComplet(db);
        const eleveCible = classementActuel.find(e => e.id == eleveCibleId);
        if (!eleveCible) return res.status(404).json({ message: "Élève cible non trouvé." });

        let moyenneViseeNum;

        if (rangVise) {
            const rangCible = parseInt(rangVise, 10);
            const eleveAuRangCible = classementActuel.find(e => e.rang === rangCible) || classementActuel[rangCible - 1];
            if (!eleveAuRangCible) return res.status(400).json({ message: `Le rang ${rangCible} est invalide.` });
            moyenneViseeNum = parseFloat(eleveAuRangCible.moyenne);
        } else {
            moyenneViseeNum = parseFloat(moyenneVisee);
        }

        let matieresAAnalyser = [];
        if (matiereIds && matiereIds.length > 0) {
            const placeholders = matiereIds.map(() => '?').join(',');
            const [selectedMatieres] = await db.query(`SELECT id, nom_matiere, coefficient FROM matieres WHERE id IN (${placeholders})`, matiereIds);
            matieresAAnalyser = selectedMatieres;
        } else {
            const [toutesLesMatieres] = await db.query("SELECT id, nom_matiere, coefficient FROM matieres");
            matieresAAnalyser = toutesLesMatieres;
        }

        const suggestionsFinales = [];
        let isAnyScenarioPossible = false;

        for (const matiere of matieresAAnalyser) {
            if (eleveCible.notesDetail[matiere.id]) {
                const noteActuelleCible = eleveCible.notesDetail[matiere.id].note;
                const coeffMatiere = parseFloat(matiere.coefficient);

                const [allMatieresForCalc] = await db.query("SELECT coefficient FROM matieres");
                const totalCoeffGlobalForCalc = allMatieresForCalc.reduce((sum, m) => sum + parseFloat(m.coefficient), 0);
                if (totalCoeffGlobalForCalc === 0) continue;

                const pointsActuels = eleveCible.moyenne * totalCoeffGlobalForCalc;
                const pointsAutresMatieres = pointsActuels - (noteActuelleCible * coeffMatiere);
                const pointsVises = moyenneViseeNum * totalCoeffGlobalForCalc;
                const pointsNecessairesMatiere = pointsVises - pointsAutresMatieres;
                const noteNecessaire = pointsNecessairesMatiere / coeffMatiere;

                if (noteNecessaire < 0 || noteNecessaire > 20) continue;
                isAnyScenarioPossible = true;

                // >>> AMÉLIORATION 1 : Chercher des notes "discrètes" <<<
                // On calcule la moyenne de la classe pour cette matière
                const [[{ avg_note }]] = await db.query("SELECT AVG(note) as avg_note FROM copies WHERE matiere_id = ? AND note IS NOT NULL", [matiere.id]);
                const classAverage = avg_note || 10.0; // Si pas de notes, on prend 10 par défaut

                // On modifie la requête pour trouver un compromis
                const [donneursPotentiels] = await db.query(
                    `SELECT c.id as copie_id, e.id as eleve_id, e.nom, e.prenom, c.note
                     FROM copies c JOIN eleves e ON c.eleve_id = e.id
                     WHERE c.matiere_id = ? AND c.eleve_id != ? AND c.note IS NOT NULL
                     -- On pondère : 60% d'importance pour atteindre l'objectif, 40% pour être discret
                     ORDER BY (ABS(c.note - ?) * 0.6 + ABS(c.note - ?) * 0.4) ASC
                     LIMIT 15`,
                    [matiere.id, eleveCibleId, noteNecessaire, classAverage]
                );

                for (const donneur of donneursPotentiels) {
                    const classementSimule = classementActuel.map(e => ({ ...e }));
                    const cibleSimule = classementSimule.find(e => e.id == eleveCibleId);
                    const donneurSimule = classementSimule.find(e => e.id == donneur.eleve_id);
                    if(!donneurSimule) continue;
                    const pointsCibleAvant = cibleSimule.moyenne * totalCoeffGlobalForCalc;
                    const pointsCibleApres = pointsCibleAvant - (noteActuelleCible * coeffMatiere) + (donneur.note * coeffMatiere);
                    cibleSimule.moyenne = pointsCibleApres / totalCoeffGlobalForCalc;
                    const pointsDonneurAvant = donneurSimule.moyenne * totalCoeffGlobalForCalc;
                    const pointsDonneurApres = pointsDonneurAvant - (donneur.note * coeffMatiere) + (noteActuelleCible * coeffMatiere);
                    donneurSimule.moyenne = pointsDonneurApres / totalCoeffGlobalForCalc;
                    classementSimule.sort((a, b) => b.moyenne - a.moyenne);
                    let rang = 0, lastMoyenne = -1, count = 1;
                    classementSimule.forEach(e => {
                        if (e.moyenne.toFixed(4) !== lastMoyenne) { rang += count; count = 1; } else { count++; }
                        e.nouveau_rang = rang;
                        lastMoyenne = e.moyenne.toFixed(4);
                    });
                    suggestionsFinales.push({
                        matiere: { id: matiere.id, nom: matiere.nom_matiere },
                        copieIdCible: eleveCible.notesDetail[matiere.id].copie_id,
                        donneur: { id: donneur.eleve_id, nom: donneur.nom, prenom: donneur.prenom, rang_actuel: donneurSimule.rang, copie_id: donneur.copie_id },
                        noteAEchanger: donneur.note,
                        simulation: {
                            moyenneCible: cibleSimule.moyenne.toFixed(2),
                            rangCible: classementSimule.find(e => e.id == eleveCibleId).nouveau_rang,
                            moyenneDonneur: donneurSimule.moyenne.toFixed(2),
                            rangDonneur: classementSimule.find(e => e.id == donneur.eleve_id).nouveau_rang,
                        }
                    });
                }
            }
        }

        if (suggestionsFinales.length > 0) {
            suggestionsFinales.sort((a, b) => Math.abs(a.simulation.moyenneCible - moyenneViseeNum) - Math.abs(b.simulation.moyenneCible - moyenneViseeNum));
            return res.json(suggestionsFinales);
        }

        if (!isAnyScenarioPossible) {
            return res.status(400).json({ message: "Objectif inatteignable. L'écart de moyenne est trop grand pour être comblé avec les notes existantes dans les matières sélectionnées." });
        } else {
            return res.json([]);
        }

    } catch (err) {
        console.error("Erreur sur /api/incognito/suggestions-moyenne:", err);
        res.status(500).json({ message: "Erreur interne du serveur." });
    }
});

// /var/www/projet-anonymat/backend/server.js

// /var/www/projet-anonymat/backend/server.js

// /var/www/projet-anonymat/backend/server.js

const swapCopyContent = async (connection, copieIdCible, copieIdDonneur) => {
    // 1. Récupérer les données complètes des deux copies à échanger et les verrouiller pour la transaction.
    const [copiesData] = await connection.query(
        "SELECT id, note, code_anonyme, note_saisie_par_utilisateur_id, cree_par_utilisateur_id FROM copies WHERE id IN (?, ?) FOR UPDATE",
        [copieIdCible, copieIdDonneur]
    );

    const copieCible = copiesData.find(c => c.id == copieIdCible);
    const copieDonneur = copiesData.find(c => c.id == copieIdDonneur);

    if (!copieCible || !copieDonneur) {
        throw new Error(`Échange impossible : une des copies (ID ${copieIdCible} ou ${copieIdDonneur}) est introuvable.`);
    }

    // 2. Échange des colonnes SANS contrainte d'unicité. Cela peut se faire directement.
    // On met à jour la copie du DONNEUR avec les données de la CIBLE.
    await connection.query(
        `UPDATE copies SET
            note = ?,
            note_saisie_par_utilisateur_id = ?,
            cree_par_utilisateur_id = ?
         WHERE id = ?`,
        [
            copieCible.note,
            copieCible.note_saisie_par_utilisateur_id,
            copieCible.cree_par_utilisateur_id,
            copieDonneur.id
        ]
    );

    // On met à jour la copie de la CIBLE avec les données (originales) du DONNEUR.
    await connection.query(
        `UPDATE copies SET
            note = ?,
            note_saisie_par_utilisateur_id = ?,
            cree_par_utilisateur_id = ?
         WHERE id = ?`,
        [
            copieDonneur.note,
            copieDonneur.note_saisie_par_utilisateur_id,
            copieDonneur.cree_par_utilisateur_id,
            copieCible.id
        ]
    );

    // 3. Échange de la colonne 'code_anonyme' (contrainte UNIQUE) via une méthode sécurisée en 3 étapes.
    const tempCodeAnonyme = `swap-${copieCible.code_anonyme}-${Date.now()}`;

    // Étape A: La cible prend une valeur temporaire unique.
    await connection.query(
        `UPDATE copies SET code_anonyme = ? WHERE id = ?`,
        [tempCodeAnonyme, copieCible.id]
    );

    // Étape B: Le donneur prend l'ancienne valeur de la cible.
    await connection.query(
        `UPDATE copies SET code_anonyme = ? WHERE id = ?`,
        [copieCible.code_anonyme, copieDonneur.id]
    );

    // Étape C: La cible prend l'ancienne valeur du donneur.
    await connection.query(
        `UPDATE copies SET code_anonyme = ? WHERE id = ?`,
        [copieDonneur.code_anonyme, copieCible.id]
    );
};

app.post(apiPaths.incognito.executerEchange, authenticateToken, checkRole(['admin']), async (req, res) => {
    const { copieIdCible, copieIdDonneur } = req.body;
    if (!copieIdCible || !copieIdDonneur) {
        return res.status(400).json({ message: "Les identifiants des deux copies sont requis." });
    }
    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();
        await swapCopyContent(connection, copieIdCible, copieIdDonneur);
        await connection.commit();

        await logActivity(req.user.id, req.user.nom_utilisateur, 'ECHANGE_NOTE_UNIQUE', `A échangé le contenu des copies ID ${copieIdCible} et ID ${copieIdDonneur}.`);
        res.status(200).json({ message: "L'échange a été effectué en toute discrétion." });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur /api/incognito/executer-echange:", err);
        res.status(500).json({ message: err.message || "L'échange a échoué." });
    } finally {
        connection.release();
    }
});

app.post(apiPaths.incognito.executerPlan, authenticateToken, checkRole(['admin']), async (req, res) => {
    const { plan } = req.body;
    if (!Array.isArray(plan) || plan.length === 0) {
        return res.status(400).json({ message: "Le plan d'action est invalide ou vide." });
    }
    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();
        for (const swap of plan) {
            const copieIdCible = swap.copieIdCible;
            const copieIdDonneur = swap.donneur.copie_id;
            if (!copieIdCible || !copieIdDonneur) {
                throw new Error("Un échange dans le plan est mal formaté. Opération annulée.");
            }
            await swapCopyContent(connection, copieIdCible, copieIdDonneur);
        }
        await connection.commit();

        const planDescription = plan.map(s => `(Cible:${s.copieIdCible}<->Donneur:${s.donneur.copie_id})`).join(', ');
        await logActivity(req.user.id, req.user.nom_utilisateur, 'ECHANGE_NOTE_PLAN', `A exécuté un plan de ${plan.length} échange(s): ${planDescription}`);
        res.status(200).json({ message: "Le plan a été exécuté avec succès." });
    } catch (err) {
        await connection.rollback();
        console.error("Erreur sur /api/incognito/executer-plan:", err);
        res.status(500).json({ message: err.message || "L'exécution du plan a échoué." });
    } finally {
        connection.release();
    }
});

app.post('/api/logs/frontend-activity', authenticateToken, async (req, res) => {
    try {
        const { description } = req.body;
        const { id, nom_utilisateur } = req.user;

        if (!description || description.trim() === '') {
            return res.status(400).send(); // Requête incorrecte si pas de description
        }
        
        // On utilise un type d'action spécifique pour les différencier
        await logActivity(id, nom_utilisateur, 'ACTION_FRONTEND', description);
        
        res.status(200).send(); // On répond juste "OK"
    } catch (err) {
        console.error("Erreur lors du logging de l'activité frontend:", err);
        res.status(500).send();
    }
});

// DANS backend/server.js (à ajouter avant la ligne app.listen)

app.get('/api/dashboard/stats-par-examen', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        // 1. Obtenir le nombre total d'élèves une seule fois.
        const [[{ total_eleves }]] = await db.query("SELECT COUNT(*) as total_eleves FROM eleves");

        // 2. Requête principale pour agréger les données par matière.
        const query = `
            SELECT
                m.id,
                m.nom_matiere,
                COALESCE(a.nombre_absents, 0) AS nombre_absents,
                COALESCE(c.nombre_notes, 0) AS nombre_notes,
                COALESCE(c.reussite_militaire, 0) AS reussite_militaire
            FROM matieres m
            LEFT JOIN (
                SELECT matiere_id, COUNT(*) as nombre_absents
                FROM absences
                GROUP BY matiere_id
            ) a ON m.id = a.matiere_id
            LEFT JOIN (
                SELECT matiere_id,
                       COUNT(*) as nombre_notes,
                       SUM(CASE WHEN note >= 12 THEN 1 ELSE 0 END) as reussite_militaire
                FROM copies
                WHERE note IS NOT NULL AND eleve_id IS NOT NULL
                GROUP BY matiere_id
            ) c ON m.id = c.matiere_id
            ORDER BY m.nom_matiere;
        `;

        const [examens] = await db.query(query);

        // 3. Calculer les statistiques dérivées en JavaScript
        const statsFinales = examens.map(examen => {
            const participants = total_eleves - examen.nombre_absents;
            const notes_manquantes = participants - examen.nombre_notes;
            
            return {
                ...examen,
                total_eleves: parseInt(total_eleves),
                participants: parseInt(participants),
                notes_manquantes: parseInt(notes_manquantes > 0 ? notes_manquantes : 0),
                nombre_absents: parseInt(examen.nombre_absents),
                nombre_notes: parseInt(examen.nombre_notes),
                reussite_militaire: parseInt(examen.reussite_militaire)
            };
        });

        res.json(statsFinales);

    } catch (err) {
        console.error("Erreur sur /api/dashboard/stats-par-examen :", err);
        res.status(500).json({ error: "Erreur lors de la récupération des statistiques du tableau de bord." });
    }
});

// DANS backend/server.js (à ajouter avant app.listen)

// Helper function pour déterminer la mention
// DANS backend/server.js (REMPLACER l'ancienne route /api/dashboard/full-summary)

// Helper function pour déterminer la mention (inchangée)
const getMention = (moyenne) => {
    if (moyenne === null) return 'Non classé';
    if (moyenne >= 18) return 'Excellent';
    if (moyenne >= 16) return 'Très Bien';
    if (moyenne >= 14) return 'Bien';
    if (moyenne >= 12) return 'Assez Bien';
    if (moyenne >= 10) return 'Passable';
    return 'Insuffisant';
};

app.get('/api/dashboard/full-summary', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        // --- 1. Récupération des données brutes ---
        const [[{ total_eleves }]] = await db.query("SELECT COUNT(*) as total_eleves FROM eleves");
        const [matieres] = await db.query("SELECT id, nom_matiere, coefficient FROM matieres");
        const [notes] = await db.query("SELECT eleve_id, matiere_id, note FROM copies WHERE note IS NOT NULL AND eleve_id IS NOT NULL");
        const [eleves_details] = await db.query("SELECT id, nom, prenom FROM eleves");

        if (total_eleves === 0 || matieres.length === 0) {
            return res.json({ /* renvoyer des données vides */ });
        }
        
        // --- NOUVEAU : Classement des matières ---
        const [classementMatieresRaw] = await db.query(`
            SELECT 
                m.nom_matiere,
                COUNT(c.id) as total_notes,
                SUM(CASE WHEN c.note >= 12 THEN 1 ELSE 0 END) as reussites_militaires
            FROM matieres m
            LEFT JOIN copies c ON m.id = c.matiere_id AND c.note IS NOT NULL
            GROUP BY m.id, m.nom_matiere
            ORDER BY (reussites_militaires / NULLIF(COUNT(c.id), 0)) DESC, m.nom_matiere ASC
        `);
        const classementMatieres = classementMatieresRaw.map(m => ({
            nom: m.nom_matiere,
            tauxReussite: m.total_notes > 0 ? ((m.reussites_militaires / m.total_notes) * 100).toFixed(1) : "0.0",
        }));


        // --- 2. Calcul des moyennes individuelles ---
        const totalCoefficients = matieres.reduce((sum, m) => sum + (m.coefficient || 0), 0);
        const moyennesEleves = [];
        if (totalCoefficients > 0) {
            const notesMap = new Map();
            notes.forEach(n => {
                if (!notesMap.has(n.eleve_id)) notesMap.set(n.eleve_id, []);
                notesMap.get(n.eleve_id).push({ matiere_id: n.matiere_id, note: n.note });
            });
            eleves_details.forEach(eleve => {
                const notesDeEleve = notesMap.get(eleve.id) || [];
                if (notesDeEleve.length > 0) {
                    let totalPoints = 0;
                    notesDeEleve.forEach(noteInfo => {
                        const matiere = matieres.find(m => m.id === noteInfo.matiere_id);
                        if (matiere) totalPoints += noteInfo.note * (matiere.coefficient || 0);
                    });
                    const moyenne = totalPoints / totalCoefficients;
                    moyennesEleves.push({ ...eleve, moyenne, notesDetail: notesDeEleve });
                }
            });
        }
        
        moyennesEleves.sort((a, b) => a.moyenne - b.moyenne); // Trier par moyenne croissante

        // --- NOUVEAU : Élèves à suivre (avec détails matières) ---
        const elevesASuivre = moyennesEleves.slice(0, 5).map(e => {
            const matieresFaibles = e.notesDetail
                .filter(n => n.note < 10)
                .map(n => {
                    const matiereInfo = matieres.find(m => m.id === n.matiere_id);
                    return matiereInfo ? matiereInfo.nom_matiere : 'Inconnue';
                });
            return {
                nom: `${e.prenom} ${e.nom}`,
                moyenne: e.moyenne.toFixed(2),
                matieres: matieresFaibles
            };
        });

        // --- 3. Calcul des statistiques agrégées (inchangé) ---
        const moyenneGenerale = moyennesEleves.length > 0 ? moyennesEleves.reduce((sum, e) => sum + e.moyenne, 0) / moyennesEleves.length : 0;
        const totalAdmisMilitaire = moyennesEleves.filter(e => e.moyenne >= 12).length;
        const tauxReussite = moyennesEleves.length > 0 ? (totalAdmisMilitaire / moyennesEleves.length) * 100 : 0;
        const repartitionMentions = { 'Excellent': 0, 'Très Bien': 0, 'Bien': 0, 'Assez Bien': 0, 'Passable': 0, 'Insuffisant': 0 };
        moyennesEleves.forEach(e => {
            const mention = getMention(e.moyenne);
            if (repartitionMentions[mention] !== undefined) repartitionMentions[mention]++;
        });
        const [repartitionNotes] = await db.query(`
            SELECT
                SUM(CASE WHEN note < 10 THEN 1 ELSE 0 END) as '0-9.99',
                SUM(CASE WHEN note >= 10 AND note < 12 THEN 1 ELSE 0 END) as '10-11.99',
                SUM(CASE WHEN note >= 12 AND note < 14 THEN 1 ELSE 0 END) as '12-13.99',
                SUM(CASE WHEN note >= 14 AND note < 16 THEN 1 ELSE 0 END) as '14-15.99',
                SUM(CASE WHEN note >= 16 THEN 1 ELSE 0 END) as '16-20'
            FROM copies WHERE note IS NOT NULL
        `);
        
        res.json({
            statCards: {
                totalEleves: total_eleves,
                moyenneGenerale: moyenneGenerale.toFixed(2),
                totalAdmis: totalAdmisMilitaire,
                tauxReussite: tauxReussite.toFixed(1)
            },
            repartitionMentions,
            repartitionNotes: repartitionNotes[0],
            classementMatieres, // NOUVELLE DONNÉE
            elevesASuivre       // DONNÉE MODIFIÉE
        });
    } catch (err) {
        console.error("Erreur sur /api/dashboard/full-summary :", err);
        res.status(500).json({ error: "Erreur lors de la récupération de la synthèse du tableau de bord." });
    }
});

// DANS backend/server.js (AJOUTER CE BLOC AVANT app.listen)

// On réutilise la fonction helper pour les mentions
const getMentionForNote = (note) => {
    if (note === null) return 'N/A';
    if (note >= 18) return 'Excellent';
    if (note >= 16) return 'Très Bien';
    if (note >= 14) return 'Bien';
    if (note >= 12) return 'Assez Bien';
    if (note >= 10) return 'Passable';
    return 'Insuffisant';
};

// DANS backend/server.js (REMPLACER l'ancienne route /api/dashboard/full-summary)

// DANS backend/server.js
// REMPLACEZ la route /api/dashboard/summary-by-exam-type par celle-ci

app.get('/api/dashboard/summary-by-exam-type', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const notesQuery = `
            SELECT
                c.type_examen, c.note, m.nom_matiere,
                e.id as eleve_id, e.prenom, e.nom, e.numero_incorporation, e.escadron, e.peloton
            FROM copies c
            JOIN eleves e ON c.eleve_id = e.id
            JOIN matieres m ON c.matiere_id = m.id
            WHERE c.note IS NOT NULL AND c.eleve_id IS NOT NULL AND c.type_examen IS NOT NULL
        `;
        const [allNotes] = await db.query(notesQuery);

        const absencesQuery = `
            SELECT a.matiere_id, a.motif, e.id as eleve_id, e.nom, e.prenom
            FROM absences a JOIN eleves e ON a.eleve_id = e.id
        `;
        const [allAbsences] = await db.query(absencesQuery);
        
        if (allNotes.length === 0) return res.json([]);

        const dataByExam = allNotes.reduce((acc, note) => {
            if (!acc[note.type_examen]) acc[note.type_examen] = [];
            acc[note.type_examen].push(note);
            return acc;
        }, {});

        const finalSummary = Object.entries(dataByExam).map(([typeExamen, notes]) => {
            // CORRECTION BUG NaN : on vérifie que le tableau n'est pas vide
            const moyenne = notes.length > 0 ? notes.reduce((sum, n) => sum + n.note, 0) / notes.length : 0;
            const participantsSet = new Set(notes.map(n => n.eleve_id));
            
            const repartitionMentions = { 'Excellent': 0, 'Très Bien': 0, 'Bien': 0, 'Assez Bien': 0, 'Passable': 0, 'Insuffisant': 0 };
            const getMention = (note) => {
                if (note >= 18) return 'Excellent'; if (note >= 16) return 'Très Bien';
                if (note >= 14) return 'Bien'; if (note >= 12) return 'Assez Bien';
                if (note >= 10) return 'Passable'; return 'Insuffisant';
            };
            notes.forEach(n => repartitionMentions[getMention(n.note)]++);

            let uniqueStudentsNotes = Array.from(participantsSet).map(eleveId => {
                const studentNotes = notes.filter(n => n.eleve_id === eleveId);
                const firstNote = studentNotes[0];
                return {
                    id: eleveId,
                    nom: `${firstNote.prenom} ${firstNote.nom}`,
                    prenom: firstNote.prenom,
                    nom_famille: firstNote.nom,
                    numero_incorporation: firstNote.numero_incorporation,
                    escadron: firstNote.escadron,
                    peloton: firstNote.peloton,
                    note: studentNotes.length > 0 ? studentNotes.reduce((sum, n) => sum + n.note, 0) / studentNotes.length : 0,
                    matieresFaibles: studentNotes.filter(n => n.note < 10).map(n => ({ nom: n.nom_matiere, note: n.note }))
                };
            });

            // Calculer le rang DANS l'examen
            uniqueStudentsNotes.sort((a, b) => b.note - a.note);
            uniqueStudentsNotes = uniqueStudentsNotes.map((student, index) => ({...student, rang: index + 1}));

            const elevesEnDifficulte = uniqueStudentsNotes
                .filter(student => student.matieresFaibles.length > 0)
                .sort((a, b) => a.note - b.note);

            // Lister les absents pour cet examen
            const matieresDeLExamenIds = [...new Set(notes.map(n => n.matiere_id))];
            const absentsPourCetExamen = allAbsences
                .filter(absence => matieresDeLExamenIds.includes(absence.matiere_id))
                .map(a => ({ nom: `${a.prenom} ${a.nom}`, motif: a.motif || 'Non spécifié' }));

            return {
                typeExamen,
                stats: { participants: participantsSet.size, moyenne: moyenne.toFixed(2) },
                repartitionMentions,
                elevesEnDifficulte,
                absents: [...new Map(absentsPourCetExamen.map(item => [item['nom'], item])).values()] // Dédoublonner
            };
        });
        res.json(finalSummary);
    } catch (err) {
        console.error("Erreur sur /api/dashboard/summary-by-exam-type :", err);
        res.status(500).json({ error: "Erreur lors de la récupération de la synthèse par examen." });
    }
});

// AJOUTEZ CET NOUVEL ENDPOINT (ou remplacez full-summary si vous l'aviez)
app.get('/api/dashboard/global-summary', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        const [matieres] = await db.query("SELECT id, coefficient FROM matieres");
        const [notes] = await db.query("SELECT eleve_id, note FROM copies WHERE note IS NOT NULL AND eleve_id IS NOT NULL");
        
        const totalCoefficients = matieres.reduce((sum, m) => sum + (m.coefficient || 0), 0);
        let moyennesEleves = [];
        if (totalCoefficients > 0) {
            const notesMap = notes.reduce((acc, n) => {
                if (!acc[n.eleve_id]) acc[n.eleve_id] = 0;
                acc[n.eleve_id] += n.note; // Simplification, suppose un coeff 1 si non défini partout
                return acc;
            }, {});
            moyennesEleves = Object.values(notesMap).map(totalPoints => totalPoints / totalCoefficients);
        }

        const repartitionMentions = { 'Excellent': 0, 'Très Bien': 0, 'Bien': 0, 'Assez Bien': 0, 'Passable': 0, 'Insuffisant': 0 };
        const getMention = (moyenne) => {
            if (moyenne >= 18) return 'Excellent'; if (moyenne >= 16) return 'Très Bien';
            if (moyenne >= 14) return 'Bien'; if (moyenne >= 12) return 'Assez Bien';
            if (moyenne >= 10) return 'Passable'; return 'Insuffisant';
        };
        moyennesEleves.forEach(moyenne => repartitionMentions[getMention(moyenne)]++);
        
        const [classementMatieres] = await db.query(`
            SELECT m.nom_matiere, AVG(c.note) as moyenne
            FROM copies c JOIN matieres m ON c.matiere_id = m.id
            WHERE c.note IS NOT NULL
            GROUP BY m.id, m.nom_matiere
            ORDER BY moyenne ASC
        `);

        res.json({ repartitionMentions, classementMatieres });
    } catch (err) {
        console.error("Erreur sur /api/dashboard/global-summary :", err);
        res.status(500).json({ error: "Erreur lors de la récupération de la synthèse globale." });
    }
});

// DANS backend/server.js
// REMPLACEZ ENTIÈREMENT la route /api/dashboard/general-summary par celle-ci :

app.get('/api/dashboard/general-summary', authenticateToken, checkRole(['admin']), async (req, res) => {
    try {
        // --- 1. Récupération des données brutes (inchangé) ---
        const [eleves] = await db.query("SELECT id, prenom, nom, numero_incorporation, escadron, peloton FROM eleves");
        const [matieres] = await db.query("SELECT id, nom_matiere, coefficient FROM matieres");
        const [notes] = await db.query("SELECT eleve_id, matiere_id, note FROM copies WHERE note IS NOT NULL AND eleve_id IS NOT NULL");
        const [absents] = await db.query(`
            SELECT e.id as eleve_id, e.nom, e.prenom, a.motif, m.nom_matiere
            FROM absences a JOIN eleves e ON a.eleve_id = e.id JOIN matieres m ON a.matiere_id = m.id
        `);

        // --- 2. Calcul du classement général individuel (inchangé) ---
        const totalCoefficients = matieres.reduce((sum, m) => sum + (parseFloat(m.coefficient) || 0), 0);
        const notesMap = new Map();
        notes.forEach(n => {
            if (!notesMap.has(n.eleve_id)) notesMap.set(n.eleve_id, []);
            notesMap.get(n.eleve_id).push({ matiere_id: n.matiere_id, note: parseFloat(n.note) });
        });

        let classementCalcules = eleves.map(eleve => {
            let totalPoints = 0;
            const notesDeEleve = notesMap.get(eleve.id) || [];
            const notesDetail = {};
            matieres.forEach(m => { notesDetail[m.nom_matiere] = { note: null }; });
            
            notesDeEleve.forEach(noteInfo => {
                const matiere = matieres.find(m => m.id === noteInfo.matiere_id);
                if (matiere && matiere.coefficient > 0) {
                    totalPoints += noteInfo.note * matiere.coefficient;
                    notesDetail[matiere.nom_matiere] = { note: noteInfo.note };
                }
            });

            const moyenne = (totalCoefficients > 0 && notesDeEleve.length > 0) ? (totalPoints / totalCoefficients) : null;
            return { ...eleve, moyenne, notesDetail };
        });

        classementCalcules.sort((a, b) => (b.moyenne ?? -1) - (a.moyenne ?? -1));
        
        let rang = 0; let lastMoyenne = -1; let studentsAtCurrentRank = 1;
        classementCalcules = classementCalcules.map((eleve, index) => {
             if (eleve.moyenne === null) return { ...eleve, rang: 'NC' };
             if (eleve.moyenne !== lastMoyenne) {
                rang = rang + studentsAtCurrentRank;
                studentsAtCurrentRank = 1;
            } else { studentsAtCurrentRank++; }
            lastMoyenne = eleve.moyenne;
            const isExAequo = (index > 0 && eleve.moyenne === classementCalcules[index - 1].moyenne) || (index < classementCalcules.length - 1 && eleve.moyenne === classementCalcules[index + 1].moyenne);
            return { ...eleve, rang: isExAequo ? `${rang} ex` : rang };
        });

        // --- 3. Calcul des statistiques agrégées ---
        // --- CORRECTION ICI ---
        const getMention = (moyenne) => {
            // Cette version est plus robuste et gère tous les cas (null, undefined, 0, etc.)
            if (typeof moyenne !== 'number' || isNaN(moyenne)) return 'Non Classé';
            if (moyenne >= 18) return 'Excellent';
            if (moyenne >= 16) return 'Très Bien';
            if (moyenne >= 14) return 'Bien';
            if (moyenne >= 12) return 'Assez Bien';
            if (moyenne >= 10) return 'Passable';
            return 'Insuffisant';
        };
        const repartitionMentions = { 'Excellent': 0, 'Très Bien': 0, 'Bien': 0, 'Assez Bien': 0, 'Passable': 0, 'Insuffisant': 0, 'Non Classé': 0 };
        classementCalcules.forEach(e => {
            const mention = getMention(e.moyenne);
            if (repartitionMentions.hasOwnProperty(mention)) {
                repartitionMentions[mention]++;
            }
        });
        
        const [classementMatieres] = await db.query(`
            SELECT m.nom_matiere, AVG(c.note) as moyenne
            FROM copies c JOIN matieres m ON c.matiere_id = m.id WHERE c.note IS NOT NULL GROUP BY m.id ORDER BY moyenne ASC
        `);

        // --- 4. Identification des élèves à suivre (inchangé) ---
        const elevesEnDifficulte = classementCalcules.filter(e => e.moyenne !== null && e.moyenne < 10).sort((a, b) => a.moyenne - b.moyenne);

        // --- 5. Calcul des statistiques par escadron (inchangé) ---
        const statsParEscadronGroupes = classementCalcules
            .filter(e => e.moyenne !== null)
            .reduce((acc, eleve) => {
                const escadron = eleve.escadron || 'Non assigné';
                if (!acc[escadron]) {
                    acc[escadron] = { nom: escadron, sommeMoyennes: 0, totalEleves: 0, enDifficulte: 0, reussiteMilitaire: 0 };
                }
                acc[escadron].sommeMoyennes += eleve.moyenne;
                acc[escadron].totalEleves++;
                if (eleve.moyenne < 10) acc[escadron].enDifficulte++;
                if (eleve.moyenne >= 12) acc[escadron].reussiteMilitaire++;
                return acc;
            }, {});

        const statsParEscadron = Object.values(statsParEscadronGroupes)
            .map(escadron => ({ ...escadron, moyenne: escadron.totalEleves > 0 ? (escadron.sommeMoyennes / escadron.totalEleves) : 0, }))
            .sort((a, b) => b.moyenne - a.moyenne);

        res.json({
            repartitionMentions,
            classementMatieres,
            elevesEnDifficulte,
            absents,
            statsParEscadron,
        });

    } catch (err) {
        console.error("Erreur sur /api/dashboard/general-summary :", err);
        res.status(500).json({ error: "Erreur lors de la récupération de la synthèse générale." });
    }
});

// NOUVEL ENDPOINT : Récupérer les 150 dernières saisies directes de l'utilisateur
app.get('/api/copies/mes-saisies-directes-recentes', authenticateToken, checkRole(['admin', 'operateur_note']), async (req, res) => {
    try {
        const utilisateurId = req.user.id;
        const query = `
            SELECT
                c.id AS copie_id,
                c.note,
                c.note_saisie_a AS date_saisie,
                e.nom,
                e.prenom,
                e.numero_incorporation,
                m.nom_matiere
            FROM copies c
            JOIN eleves e ON c.eleve_id = e.id
            JOIN matieres m ON c.matiere_id = m.id
            WHERE c.note_saisie_par_utilisateur_id = ?
              AND c.code_anonyme IS NULL -- S'assurer que ce sont bien des saisies directes
            ORDER BY c.note_saisie_a DESC
            LIMIT 150;
        `;
        const [rows] = await db.query(query, [utilisateurId]);
        res.json(rows);
    } catch (err) {
        console.error("Erreur sur /api/copies/mes-saisies-directes-recentes", err);
        res.status(500).json({ error: "Erreur interne du serveur." });
    }
});

// AJOUTER CETTE NOUVELLE ROUTE DANS backend/server.js

app.post('/api/copies/notes-directes-bulk', authenticateToken, checkRole(['admin','operateur_note']), async (req, res) => {
    const { notes } = req.body; // On attend un objet contenant un tableau "notes"
    const utilisateurId = req.user.id;

    if (!Array.isArray(notes) || notes.length === 0) {
        return res.status(400).json({ message: "Aucune note à enregistrer n'a été fournie." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();

        const valuesToInsert = [];
        const eleveMatierePairs = new Set(); // Pour vérifier les doublons dans le lot

        for (const note of notes) {
            // Validation de chaque entrée
            if (!note.eleve_id || !note.matiere_id || note.note === undefined || !note.type_examen) {
                throw new Error("Une des saisies est incomplète. Opération annulée.");
            }
            const noteNum = parseFloat(note.note);
            if (isNaN(noteNum) || noteNum < 0 || noteNum > 20) {
                throw new Error(`Note invalide (${note.note}) pour l'élève ${note.eleve_nom}. Opération annulée.`);
            }

            // Vérification des doublons dans le lot soumis
            const key = `${note.eleve_id}-${note.matiere_id}-${note.type_examen}`;
            if (eleveMatierePairs.has(key)) {
                throw new Error(`Saisie en double pour ${note.eleve_nom} (${note.type_examen}). Opération annulée.`);
            }
            eleveMatierePairs.add(key);

            // Vérification des absences
            const [absenceCheck] = await connection.query(
                "SELECT id FROM absences WHERE eleve_id = ? AND matiere_id = ?",
                [note.eleve_id, note.matiere_id]
            );
            if (absenceCheck.length > 0) {
                 throw new Error(`L'élève ${note.eleve_nom} est déclaré absent pour cette matière. Opération annulée.`);
            }
            
            // Vérification de note existante dans la BDD
            const [noteExistante] = await connection.query(
                "SELECT id FROM copies WHERE eleve_id = ? AND matiere_id = ? AND type_examen = ?",
                [note.eleve_id, note.matiere_id, note.type_examen]
            );
            if(noteExistante.length > 0) {
                throw new Error(`L'élève ${note.eleve_nom} a déjà une note pour ce type d'examen (${note.type_examen}). Opération annulée.`);
            }

            valuesToInsert.push([note.eleve_id, note.matiere_id, noteNum, note.type_examen, utilisateurId]);
        }

        if (valuesToInsert.length > 0) {
            const query = `
                INSERT INTO copies (eleve_id, matiere_id, note, type_examen, note_saisie_par_utilisateur_id)
                VALUES ?
            `;
            await connection.query(query, [valuesToInsert]);
        }

        await connection.commit();
        res.status(201).json({ message: `${valuesToInsert.length} note(s) enregistrée(s) avec succès.` });

    } catch (err) {
        await connection.rollback();
        // On renvoie le message d'erreur spécifique qui a causé le rollback
        res.status(409).json({ message: err.message || "Erreur lors de l'enregistrement en masse. Aucune note n'a été enregistrée." });
    } finally {
        connection.release();
    }
});

// AJOUTER CETTE NOUVELLE ROUTE DANS backend/server.js

app.post('/api/absences/direct-bulk', authenticateToken, checkRole(['admin','operateur_note']), async (req, res) => {
    const { absences } = req.body;
    const utilisateurId = req.user.id;

    if (!Array.isArray(absences) || absences.length === 0) {
        return res.status(400).json({ message: "Aucune absence à enregistrer." });
    }

    const connection = await db.getConnection();
    try {
        await connection.beginTransaction();

        const valuesToInsert = [];
        for (const abs of absences) {
            if (!abs.eleve_id || !abs.matiere_id) {
                throw new Error("Données d'absence incomplètes. Opération annulée.");
            }
            // Vérification pour éviter de marquer absent un élève déjà noté
            const [noteCheck] = await connection.query(
                "SELECT id FROM copies WHERE eleve_id = ? AND matiere_id = ? AND note IS NOT NULL",
                [abs.eleve_id, abs.matiere_id]
            );
            if (noteCheck.length > 0) {
                // Le nom de l'élève n'est pas dans la requête, donc on met un message générique
                throw new Error(`Un élève dans la liste a déjà une note pour cette matière. Opération annulée.`);
            }
            valuesToInsert.push([abs.eleve_id, abs.matiere_id, utilisateurId, abs.motif || null]);
        }
        
        // INSERT IGNORE évite les erreurs si l'absence est déjà enregistrée, ce qui est parfait pour un enregistrement en masse.
        const sql = "INSERT IGNORE INTO absences (eleve_id, matiere_id, enregistre_par_utilisateur_id, motif) VALUES ?";
        const [result] = await connection.query(sql, [valuesToInsert]);

        await connection.commit();
        res.status(201).json({ message: `${result.affectedRows} absence(s) enregistrée(s). ${valuesToInsert.length - result.affectedRows} étaient déjà présentes.` });

    } catch (err) {
        await connection.rollback();
        res.status(409).json({ message: err.message || "Erreur lors de l'enregistrement des absences." });
    } finally {
        connection.release();
    }
});

const HOST = '0.0.0.0';
app.listen(port, HOST, () => {
    console.log(`Serveur backend démarré sur le port ${port} et accessible sur le réseau.`);
});
